// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 4.6.0 by WSRD Tencent.
// Generated from `Notify.jce'
// **********************************************************************

#ifndef __NOTIFY_H_
#define __NOTIFY_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
using namespace std;
#include "servant/ServantProxy.h"
#include "servant/Servant.h"


namespace taf
{
    enum NOTIFYLEVEL
    {
        NOTIFYNORMAL,
        NOTIFYWARN,
        NOTIFYERROR,
    };
    inline string etos(const NOTIFYLEVEL & e)
    {
        switch(e)
        {
            case NOTIFYNORMAL: return "NOTIFYNORMAL";
            case NOTIFYWARN: return "NOTIFYWARN";
            case NOTIFYERROR: return "NOTIFYERROR";
            default: return "";
        }
        return "";
    }
    inline int stoe(const string & s, NOTIFYLEVEL & e)
    {
        if(s == "NOTIFYNORMAL")  { e=NOTIFYNORMAL; return 0;}
        if(s == "NOTIFYWARN")  { e=NOTIFYWARN; return 0;}
        if(s == "NOTIFYERROR")  { e=NOTIFYERROR; return 0;}

        return -1;
    }

    struct NotifyKey : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "taf.NotifyKey";
        }
        static string MD5()
        {
            return "8d61b639cda77ea57102c6b9cbb5aca2";
        }
        NotifyKey()
        :name(""),ip(""),page(0)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(name, 1);
            _os.write(ip, 2);
            _os.write(page, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(name, 1, true);
            _is.read(ip, 2, true);
            _is.read(page, 3, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(name,"name");
            _ds.display(ip,"ip");
            _ds.display(page,"page");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(name, true);
            _ds.displaySimple(ip, true);
            _ds.displaySimple(page, false);
            return _os;
        }
    public:
        std::string name;
        std::string ip;
        taf::Int32 page;
    };
    inline bool operator==(const NotifyKey&l, const NotifyKey&r)
    {
        return l.name == r.name && l.ip == r.ip && l.page == r.page;
    }
    inline bool operator!=(const NotifyKey&l, const NotifyKey&r)
    {
        return !(l == r);
    }

    struct NotifyItem : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "taf.NotifyItem";
        }
        static string MD5()
        {
            return "c9a7b07e8b044d0fcbe9339d81fbbd69";
        }
        NotifyItem()
        :sTimeStamp(""),sServerId(""),iLevel(0),sMessage("")
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(sTimeStamp, 1);
            _os.write(sServerId, 2);
            _os.write(iLevel, 3);
            _os.write(sMessage, 4);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(sTimeStamp, 1, true);
            _is.read(sServerId, 2, true);
            _is.read(iLevel, 3, true);
            _is.read(sMessage, 4, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(sTimeStamp,"sTimeStamp");
            _ds.display(sServerId,"sServerId");
            _ds.display(iLevel,"iLevel");
            _ds.display(sMessage,"sMessage");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(sTimeStamp, true);
            _ds.displaySimple(sServerId, true);
            _ds.displaySimple(iLevel, true);
            _ds.displaySimple(sMessage, false);
            return _os;
        }
    public:
        std::string sTimeStamp;
        std::string sServerId;
        taf::Int32 iLevel;
        std::string sMessage;
    };
    inline bool operator==(const NotifyItem&l, const NotifyItem&r)
    {
        return l.sTimeStamp == r.sTimeStamp && l.sServerId == r.sServerId && l.iLevel == r.iLevel && l.sMessage == r.sMessage;
    }
    inline bool operator!=(const NotifyItem&l, const NotifyItem&r)
    {
        return !(l == r);
    }

    struct NotifyInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "taf.NotifyInfo";
        }
        static string MD5()
        {
            return "d509960be39ae76bb89d5556bc299c13";
        }
        NotifyInfo()
        :nextpage(0)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(nextpage, 1);
            _os.write(notifyItems, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(nextpage, 1, true);
            _is.read(notifyItems, 2, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(nextpage,"nextpage");
            _ds.display(notifyItems,"notifyItems");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(nextpage, true);
            _ds.displaySimple(notifyItems, false);
            return _os;
        }
    public:
        taf::Int32 nextpage;
        vector<taf::NotifyItem> notifyItems;
    };
    inline bool operator==(const NotifyInfo&l, const NotifyInfo&r)
    {
        return l.nextpage == r.nextpage && l.notifyItems == r.notifyItems;
    }
    inline bool operator!=(const NotifyInfo&l, const NotifyInfo&r)
    {
        return !(l == r);
    }


    /* callback of async proxy for client */
    class NotifyPrxCallback: public taf::ServantProxyCallback
    {
    public:
        virtual ~NotifyPrxCallback(){}
        virtual void callback_reportServer()
        { throw std::runtime_error("callback_reportServer() overloading incorrect."); }
        virtual void callback_reportServer_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_reportServer_exception() overloading incorrect."); }

        virtual void callback_notifyServer()
        { throw std::runtime_error("callback_notifyServer() overloading incorrect."); }
        virtual void callback_notifyServer_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_notifyServer_exception() overloading incorrect."); }

        virtual void callback_getNotifyInfo(taf::Int32 ret,  const taf::NotifyInfo& stInfo)
        { throw std::runtime_error("callback_getNotifyInfo() overloading incorrect."); }
        virtual void callback_getNotifyInfo_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_getNotifyInfo_exception() overloading incorrect."); }

    public:
        int onDispatch(taf::ReqMessagePtr msg);
    };
    typedef taf::TC_AutoPtr<NotifyPrxCallback> NotifyPrxCallbackPtr;

    /* proxy for client */
    class NotifyProxy : public taf::ServantProxy
    {
    public:
        typedef map<string, string> TAF_CONTEXT;
        void reportServer(const std::string & sServerName,const std::string & sThreadId,const std::string & sMessage,const map<string, string> &context = TAF_CONTEXT());
        void async_reportServer(NotifyPrxCallbackPtr callback,const std::string & sServerName,const std::string & sThreadId,const std::string & sMessage,const map<string, string> &context = TAF_CONTEXT());

        void notifyServer(const std::string & sServerName,taf::NOTIFYLEVEL level,const std::string & sMessage,const map<string, string> &context = TAF_CONTEXT());
        void async_notifyServer(NotifyPrxCallbackPtr callback,const std::string & sServerName,taf::NOTIFYLEVEL level,const std::string & sMessage,const map<string, string> &context = TAF_CONTEXT());

        taf::Int32 getNotifyInfo(const taf::NotifyKey & stKey,taf::NotifyInfo &stInfo,const map<string, string> &context = TAF_CONTEXT());
        void async_getNotifyInfo(NotifyPrxCallbackPtr callback,const taf::NotifyKey & stKey,const map<string, string> &context = TAF_CONTEXT());

        NotifyProxy* taf_hash(int64_t key);
    };
    typedef taf::TC_AutoPtr<NotifyProxy> NotifyPrx;

    /* servant for server */
    class Notify : public taf::Servant
    {
    public:
        virtual ~Notify(){}
        virtual void reportServer(const std::string & sServerName,const std::string & sThreadId,const std::string & sMessage,taf::JceCurrentPtr current) = 0;
        static void async_response_reportServer(taf::JceCurrentPtr current);

        virtual void notifyServer(const std::string & sServerName,taf::NOTIFYLEVEL level,const std::string & sMessage,taf::JceCurrentPtr current) = 0;
        static void async_response_notifyServer(taf::JceCurrentPtr current);

        virtual taf::Int32 getNotifyInfo(const taf::NotifyKey & stKey,taf::NotifyInfo &stInfo,taf::JceCurrentPtr current) = 0;
        static void async_response_getNotifyInfo(taf::JceCurrentPtr current, taf::Int32 _ret, const taf::NotifyInfo &stInfo);

    public:
        int onDispatch(taf::JceCurrentPtr _current, vector<char> &_sResponseBuffer);
    };


}

#define taf_NotifyKey_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.name,b.name);jce_copy_struct(a.ip,b.ip);jce_copy_struct(a.page,b.page);

#define taf_NotifyItem_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.sTimeStamp,b.sTimeStamp);jce_copy_struct(a.sServerId,b.sServerId);jce_copy_struct(a.iLevel,b.iLevel);jce_copy_struct(a.sMessage,b.sMessage);

#define taf_NotifyInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.nextpage,b.nextpage);jce_copy_struct(a.notifyItems,b.notifyItems);



#endif
