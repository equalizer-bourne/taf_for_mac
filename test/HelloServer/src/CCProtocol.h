/********************************************************************
 * This file is generated by program cap
 * Please do not change it directly
 * 
 * protocol name:配置中心
 * protocol version:4.0
 * protocol author:coonzhang coonzhang@tencent.com 
 * protocol desc:
********************************************************************/
#ifndef __CCProtocol_H__ 
#define __CCProtocol_H__ 

#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <netinet/in.h>
#include <stdexcept>
#include <iostream>
#include <assert.h>
#include <vector>

struct CCProtocol_Invalid: public std::runtime_error{ CCProtocol_Invalid(const std::string& s):std::runtime_error(s){}};

class CCProtocol {
public:
	enum command {
		Response = 0,/* 通用的命令响应 */
		GetConfig = 1,/* 取配置数据 */
		AddMod = 2,/* 添加接入模块 */
		AddFile = 3,/* 添加接入模块文件 */
		ModList = 4,/* 获取模块列表 */
		FileList = 5,/* 获取某一模块下的文件列表 */
		FileConf = 6,/* 获取指定文件的内容 */
		UpdateFileConf = 7,/* 更新文件内容 */
		DeleteFile = 8,/* 删除指定的文件 */
		DeleteMod = 9,/* 删除接入模块 */
		EditConfig = 10,/* 将文件置为编辑状态 */
		MakeVersion = 11,/* 打包配置文件 */
		RollBackFile = 12,/* 以文件为单元回滚配置文件 */
		RollBackMod = 13,/* 以模块为单元回滚配置文件 */
		VersionList = 14,/* 获取模块或文件的版本列表 */
		GetBigFileConf = 15,/* 获取大文件配置 */
		GetModChangedFiles = 16,/* 获取指定模块下变动的配置文件内容,包括修改,增加,删除的 */
		CmdCheckFileChanged = 17,/*  */
		CmdNeedUpdateFiles = 18,/*  */
		CmdDownloadReq = 19,/*  */
		CmdDownloadRsp = 20/*  */
	};
	enum {
	};
public:
	struct UserSession {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const UserSession& st);

		std::string name; /* 用户名,此项加type项组成用户的KEY，用于加锁解锁 */
		unsigned int type; /* 用户类型:0--UI,1--CMD,2--API */

	private:
		unsigned arraysize;
	};
	struct FileAttr {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const FileAttr& st);

		std::string modname; /* 模块名 */
		std::string filename; /* 该模块下的文件名 */

	private:
		unsigned arraysize;
	};
	struct FileContent {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const FileContent& st);

		std::string modname; /* 模块名 */
		std::string filename; /* 该模块下的文件名 */
		std::string content; /* 配置数据 */

	private:
		unsigned arraysize;
	};
	struct FileAttrForBigFile {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const FileAttrForBigFile& st);

		std::string modname; /* 模块名 */
		std::string filename; /* 该模块下的文件名 */
		std::string timestamp; /* 时间戳,用来标识内容是否变动,格式为YYYYMMDDHHMMSS */

	private:
		unsigned arraysize;
	};
	struct FileContentForBigFile {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const FileContentForBigFile& st);

		std::string modname; /* 模块名 */
		std::string filename; /* 该模块下的文件名 */
		std::string timestamp; /* 文件时间戳,格式为YYYYMMDDHHMMSS,const表示文件没变动 */
		std::string content; /* 配置数据 */

	private:
		unsigned arraysize;
	};
	struct PackHead {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const PackHead& st);

		int total; /* 包总数 */
		int prev; /* 前一包序列号 */
		int cur; /* 当前包序列号 */
		int next; /* 下一包序列号 */

	private:
		unsigned arraysize;
	};
	struct FileAttr1 {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const FileAttr1& st);

		std::string filename; /* 该模块下的文件名 */
		std::string timestamp; /* 时间戳,用来标识内容是否变动,格式为YYYYMMDDHHMMSS */

	private:
		unsigned arraysize;
	};
	struct FileChangedAttr {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const FileChangedAttr& st);

		int type; /* 0:增加,1:删除,2:修改,3:不变 */
		std::vector<std::string > files; /* 文件名列表 */

	private:
		unsigned arraysize;
	};
	struct SFileInfo {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const SFileInfo& st);

		std::string modulename; /* 模块名 */
		std::string filename; /* 文件名 */
		std::string md5; /* MD5值 */

	private:
		unsigned arraysize;
	};
	struct SDownloadReq {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const SDownloadReq& st);

		std::string modulename; /* 模块名 */
		std::string filename; /* 文件名 */
		unsigned int startPos; /* 文件的起始位置 */
		unsigned int chunkLen; /* 需要下载的长度 */

	private:
		unsigned arraysize;
	};

public:
	struct GetConfigCS {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const GetConfigCS& st);

		std::vector<FileAttr > files; /* 文件名列表,将请求的文件内容返回，不合在一起 */

	private:
		unsigned arraysize;
	};
	struct GetConfigSC {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const GetConfigSC& st);

		int result; /* 返回码,0:成功;1:无效模块2 无效文件 */
		std::vector<FileContent > configuration; /* 配置数据 */

	private:
		unsigned arraysize;
	};
	struct AddModCS {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const AddModCS& st);

		std::string modname; /* 模块名 */

	private:
		unsigned arraysize;
	};
	struct AddModSC {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const AddModSC& st);

		int result; /* 返回码,0:成功;1参数错误;2:internal error */

	private:
		unsigned arraysize;
	};
	struct AddFileCS {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const AddFileCS& st);

		std::string modname; /*  */
		std::string filename; /* 文件名 */
		std::string configuration; /* 配置数据,文件内容,可用为空 */

	private:
		unsigned arraysize;
	};
	struct AddFileSC {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const AddFileSC& st);

		int result; /* 返回码,0:成功;1:无效模块;2:文件已存在;3:internal error */

	private:
		unsigned arraysize;
	};
	struct ModListCS {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const ModListCS& st);


	private:
		unsigned arraysize;
	};
	struct ModListSC {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const ModListSC& st);

		int result; /* 返回码,0:成功 */
		std::vector<std::string > modarr; /* 模块名列表 */

	private:
		unsigned arraysize;
	};
	struct FileListCS {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const FileListCS& st);

		std::string modname; /* 模块名 */

	private:
		unsigned arraysize;
	};
	struct FileListSC {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const FileListSC& st);

		int result; /* 返回码,0:成功;1:无效模块 */
		std::vector<std::string > files; /* 模块下所有文件列表 */

	private:
		unsigned arraysize;
	};
	struct FileConfCS {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const FileConfCS& st);

		std::string modname; /* 模块名 */
		std::string filename; /* 文件名 */

	private:
		unsigned arraysize;
	};
	struct FileConfSC {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const FileConfSC& st);

		int result; /* 返回码,0:成功;1:无效模块;2:无效文件 */
		std::string configuration; /* 配置数据 */

	private:
		unsigned arraysize;
	};
	struct UpdateFileConfCS {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const UpdateFileConfCS& st);

		UserSession userInfo; /* 加解锁的key,非UI用户只填其中的type,UI要填完整 */
		std::string modname; /* 模块名 */
		std::string filename; /* 文件名 */
		std::string configuration; /* 配置数据 */

	private:
		unsigned arraysize;
	};
	struct UpdateFileConfSC {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const UpdateFileConfSC& st);

		int result; /* 返回码,0:成功;1:无效模块;2:配置格式错误;3:internal error;4:该文件正在编辑;5:无效文件6 参数错误 */

	private:
		unsigned arraysize;
	};
	struct DeleteFileCS {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const DeleteFileCS& st);

		std::string modname; /* 模块名 */
		std::string filename; /* 文件名 */

	private:
		unsigned arraysize;
	};
	struct DeleteFileSC {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const DeleteFileSC& st);

		int result; /* 返回码,0:成功;1:无效模块或文件;2:internal error */

	private:
		unsigned arraysize;
	};
	struct DeleteModCS {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const DeleteModCS& st);

		std::string modname; /* 模块名 */

	private:
		unsigned arraysize;
	};
	struct DeleteModSC {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const DeleteModSC& st);

		int result; /* 返回码,0:成功;1:无效模块;2:internal error */

	private:
		unsigned arraysize;
	};
	struct EditConfigCS {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const EditConfigCS& st);

		UserSession userInfo; /* 用户信息,加解锁的key */
		unsigned int type; /* 操作类型:0--编辑,1--取消编辑 */
		std::string modname; /* 模块名 */
		std::string filename; /* 文件名 */

	private:
		unsigned arraysize;
	};
	struct EditConfigSC {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const EditConfigSC& st);

		int result; /* 0:请求成功,1:有用户正在编辑该配置2:非法请求,3 参数错误 */

	private:
		unsigned arraysize;
	};
	struct MakeVersionCS {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const MakeVersionCS& st);

		UserSession userInfo; /* 用户信息,加解锁的key */
		int type; /* 操作类型:0--以mod作为单元打包,1--以文件作为单元打包 */
		std::string modname; /* 模块名 */
		std::string filename; /* 文件名,如果以模块为单元打包,不需要填该项 */
		std::string version; /* 目标版本号,必填 */

	private:
		unsigned arraysize;
	};
	struct MakeVersionSC {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const MakeVersionSC& st);

		int result; /* 0:更新成功,1:有用户正在更新该配,2:内部错误,3:无效模块或文件4 版本号已存在 */

	private:
		unsigned arraysize;
	};
	struct RollBackFileCS {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const RollBackFileCS& st);

		UserSession userInfo; /* 用户信息,加解锁的key */
		std::string modname; /* 模块名 */
		std::string filename; /* 文件名 */
		std::string version; /* 版本号 */

	private:
		unsigned arraysize;
	};
	struct RollBackFileSC {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const RollBackFileSC& st);

		int result; /* 返回码,0:成功;1:无效模块或文件,2 --用户在编辑该文件回滚失败,3:内部错误,4 版本非法 */

	private:
		unsigned arraysize;
	};
	struct RollBackModCS {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const RollBackModCS& st);

		UserSession userInfo; /* 用户信息,加解锁的key */
		std::string modname; /* 模块名 */
		std::string version; /* 版本号 */

	private:
		unsigned arraysize;
	};
	struct RollBackModSC {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const RollBackModSC& st);

		int result; /* 返回码,0:成功;1:无效模块或文件,2 --用户在编辑该文件回滚失败,3:内部错误,4 版本非法 */

	private:
		unsigned arraysize;
	};
	struct VersionListCS {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const VersionListCS& st);

		int type; /* 操作类型:0--获取MOD的版本列表,1-- 获取文件的版本列表 */
		std::string modname; /* 模块名,必填 */
		std::string filename; /* 文件名,如果获取mod的版本列表,不填该项 */

	private:
		unsigned arraysize;
	};
	struct VersionListSC {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const VersionListSC& st);

		int result; /* 返回码,0:成功;1:无效模块或文件,2 :内部错误 */
		std::vector<std::string > versionlist; /* 版本列表 */

	private:
		unsigned arraysize;
	};
	struct GetBigFileConfCS {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const GetBigFileConfCS& st);

		FileAttrForBigFile file; /* 文件名 */
		PackHead filePosition; /* 当前文件位置,首次获取文件将cur填写为-1 */
		int result; /* 结果：0―成功 1-网络错误 */

	private:
		unsigned arraysize;
	};
	struct GetBigFileConfSC {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const GetBigFileConfSC& st);

		int result; /* 返回码,0:成功;1:无效模块2 无效文件 */
		PackHead head; /* 本包包头 */
		FileContentForBigFile configuration; /* 配置数据 */

	private:
		unsigned arraysize;
	};
	struct GetModChangedFilesCS {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const GetModChangedFilesCS& st);

		int subCmd; /* 子命令,0:获取变更文件列表,1:获取文件内容 */
		std::string modName; /* 模块名,仅当subCmd为0时有效 */
		std::vector<FileAttr1 > localfiles; /* 文件名列表,仅当subCmd为0时有效 */
		FileAttrForBigFile file; /* 文件名,仅当subCmd为1时有效 */
		PackHead filePosition; /* 当前文件位置,首次获取文件将cur填写为-1,仅当subCmd为1时有效 */
		int result; /* 当前接收结果：0―成功 1-网络错误,仅当subCmd为1时有效 */

	private:
		unsigned arraysize;
	};
	struct GetModChangedFilesSC {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const GetModChangedFilesSC& st);

		int result; /* 返回码,0:成功;1:无效模块2 无效文件 */
		int subCmd; /* 子命令,0:获取变更文件列表,1:获取文件内容 */
		std::vector<FileChangedAttr > files; /* 变更的文件名列表,仅当subCmd为0时有效 */
		PackHead head; /* 本包包头,仅当subCmd为1时有效 */
		FileContentForBigFile configuration; /* 配置数据,仅当subCmd为1时有效 */

	private:
		unsigned arraysize;
	};
	struct ResponseSC {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const ResponseSC& st);

		int requestCmd; /*  */
		int resultCode; /*  */
		std::string resultDesc; /*  */

	private:
		unsigned arraysize;
	};
	struct ResponseCS {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const ResponseCS& st);

		int requestCmd; /*  */
		int resultCode; /*  */
		std::string resultDesc; /*  */

	private:
		unsigned arraysize;
	};
	struct CmdCheckFileChangedCS {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const CmdCheckFileChangedCS& st);

		std::vector<SFileInfo > fileList; /*  */

	private:
		unsigned arraysize;
	};
	struct CmdNeedUpdateFilesSC {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const CmdNeedUpdateFilesSC& st);

		std::vector<SFileInfo > fileList; /*  */

	private:
		unsigned arraysize;
	};
	struct CmdDownloadReqCS {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const CmdDownloadReqCS& st);

		SDownloadReq request; /* 下载请求 */

	private:
		unsigned arraysize;
	};
	struct CmdDownloadRspSC {
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const CmdDownloadRspSC& st);

		SDownloadReq origin; /* 原始下载请求 */
		unsigned int totalLen; /* 文件的总长度 */
		std::string content; /* 本次返回的文件内容 */

	private:
		unsigned arraysize;
	};

public:
	struct packc{
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		void DecodeHead(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const packc& st);
		unsigned int Len; /* 包长字段 */
		char Stx; /* stx,常量为2 */
		short Ver; /* 版本号 */
		short Cmd; /* 命令字 */
		unsigned int SeqNo; /* 序列号,递增 */
		char Etx; /* etx,常量为3 */
		GetConfigCS csGetConfig;
		AddModCS csAddMod;
		AddFileCS csAddFile;
		ModListCS csModList;
		FileListCS csFileList;
		FileConfCS csFileConf;
		UpdateFileConfCS csUpdateFileConf;
		DeleteFileCS csDeleteFile;
		DeleteModCS csDeleteMod;
		EditConfigCS csEditConfig;
		MakeVersionCS csMakeVersion;
		RollBackFileCS csRollBackFile;
		RollBackModCS csRollBackMod;
		VersionListCS csVersionList;
		GetBigFileConfCS csGetBigFileConf;
		GetModChangedFilesCS csGetModChangedFiles;
		ResponseCS csResponse;
		CmdCheckFileChangedCS csCmdCheckFileChanged;
		CmdDownloadReqCS csCmdDownloadReq;

	private:
		unsigned arraysize;
	};
	struct packs{
	public:
		void Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid);
		void Decode(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		void DecodeHead(const char* buffer,unsigned& bufferlen) throw(CCProtocol_Invalid);
		friend std::ostream& operator<<(std::ostream& ost, const packs& st);
		unsigned int Len; /* 包长字段 */
		char Stx; /* stx,常量为2 */
		short Ver; /* 版本号 */
		short Cmd; /* 命令字 */
		unsigned int SeqNo; /* 序列号,递增 */
		short Code; /* 系统级返回码 */
		char Etx; /* etx,常量为3 */
		GetConfigSC scGetConfig;
		AddModSC scAddMod;
		AddFileSC scAddFile;
		ModListSC scModList;
		FileListSC scFileList;
		FileConfSC scFileConf;
		UpdateFileConfSC scUpdateFileConf;
		DeleteFileSC scDeleteFile;
		DeleteModSC scDeleteMod;
		EditConfigSC scEditConfig;
		MakeVersionSC scMakeVersion;
		RollBackFileSC scRollBackFile;
		RollBackModSC scRollBackMod;
		VersionListSC scVersionList;
		GetBigFileConfSC scGetBigFileConf;
		GetModChangedFilesSC scGetModChangedFiles;
		ResponseSC scResponse;
		CmdNeedUpdateFilesSC scCmdNeedUpdateFiles;
		CmdDownloadRspSC scCmdDownloadRsp;

	private:
		unsigned arraysize;
	};
public:
	static void h2n_32(char *buffer,int i) {int tmp = htonl(i);memcpy(buffer,&tmp,sizeof(int));}
	static void h2n_16(char *buffer,short sh) {short tmp = htons(sh);memcpy(buffer,&tmp,sizeof(short));}
	static int n2h_32(const char *buffer) {return ntohl(*(int *)buffer);}
	static short n2h_16(const char *buffer) {return ntohs(*(short *)buffer);}
	static std::string us(int u) {char sTmp[64]; sprintf(sTmp,"%d",u); return sTmp;}
public:
	packc client;
	packs server;
};

inline void CCProtocol::UserSession::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(name.length()+2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:UserSession Encode fail: buffer is too short");
	CCProtocol::h2n_16(p,name.length());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	memcpy(p,&(name.c_str()[0]),name.length());
	buffersize+=name.length();
	p+=name.length();
	leftsize-=name.length();

	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:UserSession Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,type);
	buffersize+=4;
	p+=4;
	leftsize-=4;

}

inline void CCProtocol::FileAttr::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(modname.length()+2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:FileAttr Encode fail: buffer is too short");
	CCProtocol::h2n_16(p,modname.length());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	memcpy(p,&(modname.c_str()[0]),modname.length());
	buffersize+=modname.length();
	p+=modname.length();
	leftsize-=modname.length();

	if(filename.length()+2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:FileAttr Encode fail: buffer is too short");
	CCProtocol::h2n_16(p,filename.length());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	memcpy(p,&(filename.c_str()[0]),filename.length());
	buffersize+=filename.length();
	p+=filename.length();
	leftsize-=filename.length();

}

inline void CCProtocol::FileContent::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(modname.length()+2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:FileContent Encode fail: buffer is too short");
	CCProtocol::h2n_16(p,modname.length());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	memcpy(p,&(modname.c_str()[0]),modname.length());
	buffersize+=modname.length();
	p+=modname.length();
	leftsize-=modname.length();

	if(filename.length()+2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:FileContent Encode fail: buffer is too short");
	CCProtocol::h2n_16(p,filename.length());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	memcpy(p,&(filename.c_str()[0]),filename.length());
	buffersize+=filename.length();
	p+=filename.length();
	leftsize-=filename.length();

	if(content.length()+4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:FileContent Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,content.length());
	buffersize+=4;
	p+=4;
	leftsize-=4;
	memcpy(p,&(content.c_str()[0]),content.length());
	buffersize+=content.length();
	p+=content.length();
	leftsize-=content.length();

}

inline void CCProtocol::FileAttrForBigFile::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(modname.length()+2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:FileAttrForBigFile Encode fail: buffer is too short");
	CCProtocol::h2n_16(p,modname.length());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	memcpy(p,&(modname.c_str()[0]),modname.length());
	buffersize+=modname.length();
	p+=modname.length();
	leftsize-=modname.length();

	if(filename.length()+2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:FileAttrForBigFile Encode fail: buffer is too short");
	CCProtocol::h2n_16(p,filename.length());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	memcpy(p,&(filename.c_str()[0]),filename.length());
	buffersize+=filename.length();
	p+=filename.length();
	leftsize-=filename.length();

	if(timestamp.length()+2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:FileAttrForBigFile Encode fail: buffer is too short");
	CCProtocol::h2n_16(p,timestamp.length());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	memcpy(p,&(timestamp.c_str()[0]),timestamp.length());
	buffersize+=timestamp.length();
	p+=timestamp.length();
	leftsize-=timestamp.length();

}

inline void CCProtocol::FileContentForBigFile::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(modname.length()+2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:FileContentForBigFile Encode fail: buffer is too short");
	CCProtocol::h2n_16(p,modname.length());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	memcpy(p,&(modname.c_str()[0]),modname.length());
	buffersize+=modname.length();
	p+=modname.length();
	leftsize-=modname.length();

	if(filename.length()+2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:FileContentForBigFile Encode fail: buffer is too short");
	CCProtocol::h2n_16(p,filename.length());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	memcpy(p,&(filename.c_str()[0]),filename.length());
	buffersize+=filename.length();
	p+=filename.length();
	leftsize-=filename.length();

	if(timestamp.length()+2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:FileContentForBigFile Encode fail: buffer is too short");
	CCProtocol::h2n_16(p,timestamp.length());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	memcpy(p,&(timestamp.c_str()[0]),timestamp.length());
	buffersize+=timestamp.length();
	p+=timestamp.length();
	leftsize-=timestamp.length();

	if(content.length()+4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:FileContentForBigFile Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,content.length());
	buffersize+=4;
	p+=4;
	leftsize-=4;
	memcpy(p,&(content.c_str()[0]),content.length());
	buffersize+=content.length();
	p+=content.length();
	leftsize-=content.length();

}

inline void CCProtocol::PackHead::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:PackHead Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,total);
	buffersize+=4;
	p+=4;
	leftsize-=4;

	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:PackHead Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,prev);
	buffersize+=4;
	p+=4;
	leftsize-=4;

	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:PackHead Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,cur);
	buffersize+=4;
	p+=4;
	leftsize-=4;

	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:PackHead Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,next);
	buffersize+=4;
	p+=4;
	leftsize-=4;

}

inline void CCProtocol::FileAttr1::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(filename.length()+2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:FileAttr1 Encode fail: buffer is too short");
	CCProtocol::h2n_16(p,filename.length());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	memcpy(p,&(filename.c_str()[0]),filename.length());
	buffersize+=filename.length();
	p+=filename.length();
	leftsize-=filename.length();

	if(timestamp.length()+2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:FileAttr1 Encode fail: buffer is too short");
	CCProtocol::h2n_16(p,timestamp.length());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	memcpy(p,&(timestamp.c_str()[0]),timestamp.length());
	buffersize+=timestamp.length();
	p+=timestamp.length();
	leftsize-=timestamp.length();

}

inline void CCProtocol::FileChangedAttr::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:FileChangedAttr Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,type);
	buffersize+=4;
	p+=4;
	leftsize-=4;

	if(2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:FileChangedAttr Encode fail: buffersize is too short");
	CCProtocol::h2n_16(p,files.size());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	for(unsigned i=0;i<files.size();i++){
		if(files[i].length()+2 > leftsize) 
			throw CCProtocol_Invalid("CCProtocol:FileChangedAttr Encode fail: buffersize is too short");
		CCProtocol::h2n_16(p,files[i].length()); buffersize+=2; p+=2; leftsize-=2;
		memcpy(p,&(files[i].c_str()[0]),files[i].length());
		buffersize+=files[i].length();
		p+=files[i].length();
		leftsize-=files[i].length();
	}

}

inline void CCProtocol::SFileInfo::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(modulename.length()+2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:SFileInfo Encode fail: buffer is too short");
	CCProtocol::h2n_16(p,modulename.length());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	memcpy(p,&(modulename.c_str()[0]),modulename.length());
	buffersize+=modulename.length();
	p+=modulename.length();
	leftsize-=modulename.length();

	if(filename.length()+2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:SFileInfo Encode fail: buffer is too short");
	CCProtocol::h2n_16(p,filename.length());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	memcpy(p,&(filename.c_str()[0]),filename.length());
	buffersize+=filename.length();
	p+=filename.length();
	leftsize-=filename.length();

	if(md5.length()+2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:SFileInfo Encode fail: buffer is too short");
	CCProtocol::h2n_16(p,md5.length());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	memcpy(p,&(md5.c_str()[0]),md5.length());
	buffersize+=md5.length();
	p+=md5.length();
	leftsize-=md5.length();

}

inline void CCProtocol::SDownloadReq::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(modulename.length()+2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:SDownloadReq Encode fail: buffer is too short");
	CCProtocol::h2n_16(p,modulename.length());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	memcpy(p,&(modulename.c_str()[0]),modulename.length());
	buffersize+=modulename.length();
	p+=modulename.length();
	leftsize-=modulename.length();

	if(filename.length()+2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:SDownloadReq Encode fail: buffer is too short");
	CCProtocol::h2n_16(p,filename.length());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	memcpy(p,&(filename.c_str()[0]),filename.length());
	buffersize+=filename.length();
	p+=filename.length();
	leftsize-=filename.length();

	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:SDownloadReq Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,startPos);
	buffersize+=4;
	p+=4;
	leftsize-=4;

	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:SDownloadReq Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,chunkLen);
	buffersize+=4;
	p+=4;
	leftsize-=4;

}

inline void CCProtocol::GetConfigCS::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:GetConfigCS Encode fail: buffersize is too short");
	CCProtocol::h2n_16(p,files.size());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	for(unsigned i=0;i<files.size();i++){
		arraysize = leftsize;
		files[i].Encode(p,arraysize);
		buffersize+=arraysize;
		p+=arraysize;
		leftsize-=arraysize;
	}
}

inline void CCProtocol::GetConfigSC::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:GetConfigSC Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,result);
	buffersize+=4;
	p+=4;
	leftsize-=4;

	if(2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:GetConfigSC Encode fail: buffersize is too short");
	CCProtocol::h2n_16(p,configuration.size());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	for(unsigned i=0;i<configuration.size();i++){
		arraysize = leftsize;
		configuration[i].Encode(p,arraysize);
		buffersize+=arraysize;
		p+=arraysize;
		leftsize-=arraysize;
	}
}

inline void CCProtocol::AddModCS::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(modname.length()+1 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:AddModCS Encode fail: buffer is too short");
	*p=modname.length();
	buffersize++;
	p++;
	leftsize--;
	memcpy(p,&(modname.c_str()[0]),modname.length());
	buffersize+=modname.length();
	p+=modname.length();
	leftsize-=modname.length();

}

inline void CCProtocol::AddModSC::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:AddModSC Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,result);
	buffersize+=4;
	p+=4;
	leftsize-=4;

}

inline void CCProtocol::AddFileCS::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(modname.length()+1 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:AddFileCS Encode fail: buffer is too short");
	*p=modname.length();
	buffersize++;
	p++;
	leftsize--;
	memcpy(p,&(modname.c_str()[0]),modname.length());
	buffersize+=modname.length();
	p+=modname.length();
	leftsize-=modname.length();

	if(filename.length()+1 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:AddFileCS Encode fail: buffer is too short");
	*p=filename.length();
	buffersize++;
	p++;
	leftsize--;
	memcpy(p,&(filename.c_str()[0]),filename.length());
	buffersize+=filename.length();
	p+=filename.length();
	leftsize-=filename.length();

	if(configuration.length()+4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:AddFileCS Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,configuration.length());
	buffersize+=4;
	p+=4;
	leftsize-=4;
	memcpy(p,&(configuration.c_str()[0]),configuration.length());
	buffersize+=configuration.length();
	p+=configuration.length();
	leftsize-=configuration.length();

}

inline void CCProtocol::AddFileSC::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:AddFileSC Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,result);
	buffersize+=4;
	p+=4;
	leftsize-=4;

}

inline void CCProtocol::ModListCS::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
}

inline void CCProtocol::ModListSC::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:ModListSC Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,result);
	buffersize+=4;
	p+=4;
	leftsize-=4;

	if(2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:ModListSC Encode fail: buffersize is too short");
	CCProtocol::h2n_16(p,modarr.size());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	for(unsigned i=0;i<modarr.size();i++){
		if(modarr[i].length()+1 > leftsize) 
			throw CCProtocol_Invalid("CCProtocol:ModListSC Encode fail: buffersize is too short");
		*p=modarr[i].length();
		buffersize++;
		p++;
		leftsize--;
		memcpy(p,&(modarr[i].c_str()[0]),modarr[i].length());
		buffersize+=modarr[i].length();
		p+=modarr[i].length();
		leftsize-=modarr[i].length();
	}

}

inline void CCProtocol::FileListCS::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(modname.length()+1 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:FileListCS Encode fail: buffer is too short");
	*p=modname.length();
	buffersize++;
	p++;
	leftsize--;
	memcpy(p,&(modname.c_str()[0]),modname.length());
	buffersize+=modname.length();
	p+=modname.length();
	leftsize-=modname.length();

}

inline void CCProtocol::FileListSC::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:FileListSC Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,result);
	buffersize+=4;
	p+=4;
	leftsize-=4;

	if(2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:FileListSC Encode fail: buffersize is too short");
	CCProtocol::h2n_16(p,files.size());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	for(unsigned i=0;i<files.size();i++){
		if(files[i].length()+1 > leftsize) 
			throw CCProtocol_Invalid("CCProtocol:FileListSC Encode fail: buffersize is too short");
		*p=files[i].length();
		buffersize++;
		p++;
		leftsize--;
		memcpy(p,&(files[i].c_str()[0]),files[i].length());
		buffersize+=files[i].length();
		p+=files[i].length();
		leftsize-=files[i].length();
	}

}

inline void CCProtocol::FileConfCS::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(modname.length()+1 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:FileConfCS Encode fail: buffer is too short");
	*p=modname.length();
	buffersize++;
	p++;
	leftsize--;
	memcpy(p,&(modname.c_str()[0]),modname.length());
	buffersize+=modname.length();
	p+=modname.length();
	leftsize-=modname.length();

	if(filename.length()+1 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:FileConfCS Encode fail: buffer is too short");
	*p=filename.length();
	buffersize++;
	p++;
	leftsize--;
	memcpy(p,&(filename.c_str()[0]),filename.length());
	buffersize+=filename.length();
	p+=filename.length();
	leftsize-=filename.length();

}

inline void CCProtocol::FileConfSC::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:FileConfSC Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,result);
	buffersize+=4;
	p+=4;
	leftsize-=4;

	if(configuration.length()+4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:FileConfSC Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,configuration.length());
	buffersize+=4;
	p+=4;
	leftsize-=4;
	memcpy(p,&(configuration.c_str()[0]),configuration.length());
	buffersize+=configuration.length();
	p+=configuration.length();
	leftsize-=configuration.length();

}

inline void CCProtocol::UpdateFileConfCS::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
		arraysize = leftsize;
	userInfo.Encode(p,arraysize);
	buffersize+=arraysize;
		p+=arraysize;
		leftsize-=arraysize;
	if(modname.length()+1 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:UpdateFileConfCS Encode fail: buffer is too short");
	*p=modname.length();
	buffersize++;
	p++;
	leftsize--;
	memcpy(p,&(modname.c_str()[0]),modname.length());
	buffersize+=modname.length();
	p+=modname.length();
	leftsize-=modname.length();

	if(filename.length()+1 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:UpdateFileConfCS Encode fail: buffer is too short");
	*p=filename.length();
	buffersize++;
	p++;
	leftsize--;
	memcpy(p,&(filename.c_str()[0]),filename.length());
	buffersize+=filename.length();
	p+=filename.length();
	leftsize-=filename.length();

	if(configuration.length()+4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:UpdateFileConfCS Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,configuration.length());
	buffersize+=4;
	p+=4;
	leftsize-=4;
	memcpy(p,&(configuration.c_str()[0]),configuration.length());
	buffersize+=configuration.length();
	p+=configuration.length();
	leftsize-=configuration.length();

}

inline void CCProtocol::UpdateFileConfSC::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:UpdateFileConfSC Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,result);
	buffersize+=4;
	p+=4;
	leftsize-=4;

}

inline void CCProtocol::DeleteFileCS::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(modname.length()+1 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:DeleteFileCS Encode fail: buffer is too short");
	*p=modname.length();
	buffersize++;
	p++;
	leftsize--;
	memcpy(p,&(modname.c_str()[0]),modname.length());
	buffersize+=modname.length();
	p+=modname.length();
	leftsize-=modname.length();

	if(filename.length()+1 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:DeleteFileCS Encode fail: buffer is too short");
	*p=filename.length();
	buffersize++;
	p++;
	leftsize--;
	memcpy(p,&(filename.c_str()[0]),filename.length());
	buffersize+=filename.length();
	p+=filename.length();
	leftsize-=filename.length();

}

inline void CCProtocol::DeleteFileSC::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:DeleteFileSC Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,result);
	buffersize+=4;
	p+=4;
	leftsize-=4;

}

inline void CCProtocol::DeleteModCS::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(modname.length()+1 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:DeleteModCS Encode fail: buffer is too short");
	*p=modname.length();
	buffersize++;
	p++;
	leftsize--;
	memcpy(p,&(modname.c_str()[0]),modname.length());
	buffersize+=modname.length();
	p+=modname.length();
	leftsize-=modname.length();

}

inline void CCProtocol::DeleteModSC::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:DeleteModSC Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,result);
	buffersize+=4;
	p+=4;
	leftsize-=4;

}

inline void CCProtocol::EditConfigCS::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
		arraysize = leftsize;
	userInfo.Encode(p,arraysize);
	buffersize+=arraysize;
		p+=arraysize;
		leftsize-=arraysize;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:EditConfigCS Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,type);
	buffersize+=4;
	p+=4;
	leftsize-=4;

	if(modname.length()+1 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:EditConfigCS Encode fail: buffer is too short");
	*p=modname.length();
	buffersize++;
	p++;
	leftsize--;
	memcpy(p,&(modname.c_str()[0]),modname.length());
	buffersize+=modname.length();
	p+=modname.length();
	leftsize-=modname.length();

	if(filename.length()+1 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:EditConfigCS Encode fail: buffer is too short");
	*p=filename.length();
	buffersize++;
	p++;
	leftsize--;
	memcpy(p,&(filename.c_str()[0]),filename.length());
	buffersize+=filename.length();
	p+=filename.length();
	leftsize-=filename.length();

}

inline void CCProtocol::EditConfigSC::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:EditConfigSC Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,result);
	buffersize+=4;
	p+=4;
	leftsize-=4;

}

inline void CCProtocol::MakeVersionCS::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
		arraysize = leftsize;
	userInfo.Encode(p,arraysize);
	buffersize+=arraysize;
		p+=arraysize;
		leftsize-=arraysize;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:MakeVersionCS Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,type);
	buffersize+=4;
	p+=4;
	leftsize-=4;

	if(modname.length()+1 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:MakeVersionCS Encode fail: buffer is too short");
	*p=modname.length();
	buffersize++;
	p++;
	leftsize--;
	memcpy(p,&(modname.c_str()[0]),modname.length());
	buffersize+=modname.length();
	p+=modname.length();
	leftsize-=modname.length();

	if(filename.length()+1 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:MakeVersionCS Encode fail: buffer is too short");
	*p=filename.length();
	buffersize++;
	p++;
	leftsize--;
	memcpy(p,&(filename.c_str()[0]),filename.length());
	buffersize+=filename.length();
	p+=filename.length();
	leftsize-=filename.length();

	if(version.length()+1 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:MakeVersionCS Encode fail: buffer is too short");
	*p=version.length();
	buffersize++;
	p++;
	leftsize--;
	memcpy(p,&(version.c_str()[0]),version.length());
	buffersize+=version.length();
	p+=version.length();
	leftsize-=version.length();

}

inline void CCProtocol::MakeVersionSC::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:MakeVersionSC Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,result);
	buffersize+=4;
	p+=4;
	leftsize-=4;

}

inline void CCProtocol::RollBackFileCS::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
		arraysize = leftsize;
	userInfo.Encode(p,arraysize);
	buffersize+=arraysize;
		p+=arraysize;
		leftsize-=arraysize;
	if(modname.length()+1 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:RollBackFileCS Encode fail: buffer is too short");
	*p=modname.length();
	buffersize++;
	p++;
	leftsize--;
	memcpy(p,&(modname.c_str()[0]),modname.length());
	buffersize+=modname.length();
	p+=modname.length();
	leftsize-=modname.length();

	if(filename.length()+1 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:RollBackFileCS Encode fail: buffer is too short");
	*p=filename.length();
	buffersize++;
	p++;
	leftsize--;
	memcpy(p,&(filename.c_str()[0]),filename.length());
	buffersize+=filename.length();
	p+=filename.length();
	leftsize-=filename.length();

	if(version.length()+1 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:RollBackFileCS Encode fail: buffer is too short");
	*p=version.length();
	buffersize++;
	p++;
	leftsize--;
	memcpy(p,&(version.c_str()[0]),version.length());
	buffersize+=version.length();
	p+=version.length();
	leftsize-=version.length();

}

inline void CCProtocol::RollBackFileSC::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:RollBackFileSC Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,result);
	buffersize+=4;
	p+=4;
	leftsize-=4;

}

inline void CCProtocol::RollBackModCS::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
		arraysize = leftsize;
	userInfo.Encode(p,arraysize);
	buffersize+=arraysize;
		p+=arraysize;
		leftsize-=arraysize;
	if(modname.length()+1 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:RollBackModCS Encode fail: buffer is too short");
	*p=modname.length();
	buffersize++;
	p++;
	leftsize--;
	memcpy(p,&(modname.c_str()[0]),modname.length());
	buffersize+=modname.length();
	p+=modname.length();
	leftsize-=modname.length();

	if(version.length()+1 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:RollBackModCS Encode fail: buffer is too short");
	*p=version.length();
	buffersize++;
	p++;
	leftsize--;
	memcpy(p,&(version.c_str()[0]),version.length());
	buffersize+=version.length();
	p+=version.length();
	leftsize-=version.length();

}

inline void CCProtocol::RollBackModSC::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:RollBackModSC Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,result);
	buffersize+=4;
	p+=4;
	leftsize-=4;

}

inline void CCProtocol::VersionListCS::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:VersionListCS Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,type);
	buffersize+=4;
	p+=4;
	leftsize-=4;

	if(modname.length()+1 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:VersionListCS Encode fail: buffer is too short");
	*p=modname.length();
	buffersize++;
	p++;
	leftsize--;
	memcpy(p,&(modname.c_str()[0]),modname.length());
	buffersize+=modname.length();
	p+=modname.length();
	leftsize-=modname.length();

	if(filename.length()+1 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:VersionListCS Encode fail: buffer is too short");
	*p=filename.length();
	buffersize++;
	p++;
	leftsize--;
	memcpy(p,&(filename.c_str()[0]),filename.length());
	buffersize+=filename.length();
	p+=filename.length();
	leftsize-=filename.length();

}

inline void CCProtocol::VersionListSC::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:VersionListSC Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,result);
	buffersize+=4;
	p+=4;
	leftsize-=4;

	if(2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:VersionListSC Encode fail: buffersize is too short");
	CCProtocol::h2n_16(p,versionlist.size());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	for(unsigned i=0;i<versionlist.size();i++){
		if(versionlist[i].length()+1 > leftsize) 
			throw CCProtocol_Invalid("CCProtocol:VersionListSC Encode fail: buffersize is too short");
		*p=versionlist[i].length();
		buffersize++;
		p++;
		leftsize--;
		memcpy(p,&(versionlist[i].c_str()[0]),versionlist[i].length());
		buffersize+=versionlist[i].length();
		p+=versionlist[i].length();
		leftsize-=versionlist[i].length();
	}

}

inline void CCProtocol::GetBigFileConfCS::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
		arraysize = leftsize;
	file.Encode(p,arraysize);
	buffersize+=arraysize;
		p+=arraysize;
		leftsize-=arraysize;
		arraysize = leftsize;
	filePosition.Encode(p,arraysize);
	buffersize+=arraysize;
		p+=arraysize;
		leftsize-=arraysize;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:GetBigFileConfCS Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,result);
	buffersize+=4;
	p+=4;
	leftsize-=4;

}

inline void CCProtocol::GetBigFileConfSC::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:GetBigFileConfSC Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,result);
	buffersize+=4;
	p+=4;
	leftsize-=4;

		arraysize = leftsize;
	head.Encode(p,arraysize);
	buffersize+=arraysize;
		p+=arraysize;
		leftsize-=arraysize;
		arraysize = leftsize;
	configuration.Encode(p,arraysize);
	buffersize+=arraysize;
		p+=arraysize;
		leftsize-=arraysize;
}

inline void CCProtocol::GetModChangedFilesCS::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:GetModChangedFilesCS Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,subCmd);
	buffersize+=4;
	p+=4;
	leftsize-=4;

	if(modName.length()+1 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:GetModChangedFilesCS Encode fail: buffer is too short");
	*p=modName.length();
	buffersize++;
	p++;
	leftsize--;
	memcpy(p,&(modName.c_str()[0]),modName.length());
	buffersize+=modName.length();
	p+=modName.length();
	leftsize-=modName.length();

	if(2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:GetModChangedFilesCS Encode fail: buffersize is too short");
	CCProtocol::h2n_16(p,localfiles.size());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	for(unsigned i=0;i<localfiles.size();i++){
		arraysize = leftsize;
		localfiles[i].Encode(p,arraysize);
		buffersize+=arraysize;
		p+=arraysize;
		leftsize-=arraysize;
	}
		arraysize = leftsize;
	file.Encode(p,arraysize);
	buffersize+=arraysize;
		p+=arraysize;
		leftsize-=arraysize;
		arraysize = leftsize;
	filePosition.Encode(p,arraysize);
	buffersize+=arraysize;
		p+=arraysize;
		leftsize-=arraysize;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:GetModChangedFilesCS Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,result);
	buffersize+=4;
	p+=4;
	leftsize-=4;

}

inline void CCProtocol::GetModChangedFilesSC::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:GetModChangedFilesSC Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,result);
	buffersize+=4;
	p+=4;
	leftsize-=4;

	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:GetModChangedFilesSC Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,subCmd);
	buffersize+=4;
	p+=4;
	leftsize-=4;

	if(2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:GetModChangedFilesSC Encode fail: buffersize is too short");
	CCProtocol::h2n_16(p,files.size());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	for(unsigned i=0;i<files.size();i++){
		arraysize = leftsize;
		files[i].Encode(p,arraysize);
		buffersize+=arraysize;
		p+=arraysize;
		leftsize-=arraysize;
	}
		arraysize = leftsize;
	head.Encode(p,arraysize);
	buffersize+=arraysize;
		p+=arraysize;
		leftsize-=arraysize;
		arraysize = leftsize;
	configuration.Encode(p,arraysize);
	buffersize+=arraysize;
		p+=arraysize;
		leftsize-=arraysize;
}

inline void CCProtocol::ResponseSC::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:ResponseSC Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,requestCmd);
	buffersize+=4;
	p+=4;
	leftsize-=4;

	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:ResponseSC Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,resultCode);
	buffersize+=4;
	p+=4;
	leftsize-=4;

	if(resultDesc.length()+2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:ResponseSC Encode fail: buffer is too short");
	CCProtocol::h2n_16(p,resultDesc.length());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	memcpy(p,&(resultDesc.c_str()[0]),resultDesc.length());
	buffersize+=resultDesc.length();
	p+=resultDesc.length();
	leftsize-=resultDesc.length();

}

inline void CCProtocol::ResponseCS::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:ResponseCS Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,requestCmd);
	buffersize+=4;
	p+=4;
	leftsize-=4;

	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:ResponseCS Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,resultCode);
	buffersize+=4;
	p+=4;
	leftsize-=4;

	if(resultDesc.length()+2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:ResponseCS Encode fail: buffer is too short");
	CCProtocol::h2n_16(p,resultDesc.length());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	memcpy(p,&(resultDesc.c_str()[0]),resultDesc.length());
	buffersize+=resultDesc.length();
	p+=resultDesc.length();
	leftsize-=resultDesc.length();

}

inline void CCProtocol::CmdCheckFileChangedCS::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:CmdCheckFileChangedCS Encode fail: buffersize is too short");
	CCProtocol::h2n_16(p,fileList.size());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	for(unsigned i=0;i<fileList.size();i++){
		arraysize = leftsize;
		fileList[i].Encode(p,arraysize);
		buffersize+=arraysize;
		p+=arraysize;
		leftsize-=arraysize;
	}
}

inline void CCProtocol::CmdNeedUpdateFilesSC::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:CmdNeedUpdateFilesSC Encode fail: buffersize is too short");
	CCProtocol::h2n_16(p,fileList.size());
	buffersize+=2;
	p+=2;
	leftsize-=2;
	for(unsigned i=0;i<fileList.size();i++){
		arraysize = leftsize;
		fileList[i].Encode(p,arraysize);
		buffersize+=arraysize;
		p+=arraysize;
		leftsize-=arraysize;
	}
}

inline void CCProtocol::CmdDownloadReqCS::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
		arraysize = leftsize;
	request.Encode(p,arraysize);
	buffersize+=arraysize;
		p+=arraysize;
		leftsize-=arraysize;
}

inline void CCProtocol::CmdDownloadRspSC::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
		arraysize = leftsize;
	origin.Encode(p,arraysize);
	buffersize+=arraysize;
		p+=arraysize;
		leftsize-=arraysize;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:CmdDownloadRspSC Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,totalLen);
	buffersize+=4;
	p+=4;
	leftsize-=4;

	if(content.length()+4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:CmdDownloadRspSC Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,content.length());
	buffersize+=4;
	p+=4;
	leftsize-=4;
	memcpy(p,&(content.c_str()[0]),content.length());
	buffersize+=content.length();
	p+=content.length();
	leftsize-=content.length();

}

inline void CCProtocol::packc::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:packc Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,Len);
	buffersize+=4;
	p+=4;
	leftsize-=4;

	if(leftsize == 0) 
		throw CCProtocol_Invalid("CCProtocol:packc Encode fail: buffer is too short");
	*p=Stx;
	buffersize++;
	p++;
	leftsize--;

	if(2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:packc Encode fail: buffer is too short");
	CCProtocol::h2n_16(p,Ver);
	buffersize+=2;
	p+=2;
	leftsize-=2;

	if(2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:packc Encode fail: buffer is too short");
	CCProtocol::h2n_16(p,Cmd);
	buffersize+=2;
	p+=2;
	leftsize-=2;

	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:packc Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,SeqNo);
	buffersize+=4;
	p+=4;
	leftsize-=4;

	switch(Cmd){
	case GetConfig:
		arraysize = leftsize;
		csGetConfig.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case AddMod:
		arraysize = leftsize;
		csAddMod.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case AddFile:
		arraysize = leftsize;
		csAddFile.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case ModList:
		arraysize = leftsize;
		csModList.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case FileList:
		arraysize = leftsize;
		csFileList.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case FileConf:
		arraysize = leftsize;
		csFileConf.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case UpdateFileConf:
		arraysize = leftsize;
		csUpdateFileConf.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case DeleteFile:
		arraysize = leftsize;
		csDeleteFile.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case DeleteMod:
		arraysize = leftsize;
		csDeleteMod.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case EditConfig:
		arraysize = leftsize;
		csEditConfig.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case MakeVersion:
		arraysize = leftsize;
		csMakeVersion.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case RollBackFile:
		arraysize = leftsize;
		csRollBackFile.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case RollBackMod:
		arraysize = leftsize;
		csRollBackMod.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case VersionList:
		arraysize = leftsize;
		csVersionList.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case GetBigFileConf:
		arraysize = leftsize;
		csGetBigFileConf.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case GetModChangedFiles:
		arraysize = leftsize;
		csGetModChangedFiles.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case Response:
		arraysize = leftsize;
		csResponse.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case CmdCheckFileChanged:
		arraysize = leftsize;
		csCmdCheckFileChanged.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case CmdDownloadReq:
		arraysize = leftsize;
		csCmdDownloadReq.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	default:
		break;
	}
	if(leftsize == 0) 
		throw CCProtocol_Invalid("CCProtocol:packc Encode fail: buffer is too short");
	*p=Etx;
	buffersize++;
	p++;
	leftsize--;

	CCProtocol::h2n_32(buffer+0,buffersize); 
}

inline void CCProtocol::packs::Encode(char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	unsigned leftsize;
	leftsize = buffersize;
	char *p;
	p = buffer;
	buffersize = 0;
	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:packs Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,Len);
	buffersize+=4;
	p+=4;
	leftsize-=4;

	if(leftsize == 0) 
		throw CCProtocol_Invalid("CCProtocol:packs Encode fail: buffer is too short");
	*p=Stx;
	buffersize++;
	p++;
	leftsize--;

	if(2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:packs Encode fail: buffer is too short");
	CCProtocol::h2n_16(p,Ver);
	buffersize+=2;
	p+=2;
	leftsize-=2;

	if(2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:packs Encode fail: buffer is too short");
	CCProtocol::h2n_16(p,Cmd);
	buffersize+=2;
	p+=2;
	leftsize-=2;

	if(4 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:packs Encode fail: buffer is too short");
	CCProtocol::h2n_32(p,SeqNo);
	buffersize+=4;
	p+=4;
	leftsize-=4;

	if(2 > leftsize) 
		throw CCProtocol_Invalid("CCProtocol:packs Encode fail: buffer is too short");
	CCProtocol::h2n_16(p,Code);
	buffersize+=2;
	p+=2;
	leftsize-=2;

	switch(Cmd){
	case GetConfig:
		arraysize = leftsize;
		scGetConfig.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case AddMod:
		arraysize = leftsize;
		scAddMod.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case AddFile:
		arraysize = leftsize;
		scAddFile.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case ModList:
		arraysize = leftsize;
		scModList.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case FileList:
		arraysize = leftsize;
		scFileList.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case FileConf:
		arraysize = leftsize;
		scFileConf.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case UpdateFileConf:
		arraysize = leftsize;
		scUpdateFileConf.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case DeleteFile:
		arraysize = leftsize;
		scDeleteFile.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case DeleteMod:
		arraysize = leftsize;
		scDeleteMod.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case EditConfig:
		arraysize = leftsize;
		scEditConfig.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case MakeVersion:
		arraysize = leftsize;
		scMakeVersion.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case RollBackFile:
		arraysize = leftsize;
		scRollBackFile.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case RollBackMod:
		arraysize = leftsize;
		scRollBackMod.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case VersionList:
		arraysize = leftsize;
		scVersionList.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case GetBigFileConf:
		arraysize = leftsize;
		scGetBigFileConf.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case GetModChangedFiles:
		arraysize = leftsize;
		scGetModChangedFiles.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case Response:
		arraysize = leftsize;
		scResponse.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case CmdNeedUpdateFiles:
		arraysize = leftsize;
		scCmdNeedUpdateFiles.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	case CmdDownloadRsp:
		arraysize = leftsize;
		scCmdDownloadRsp.Encode(p,arraysize);
		p += arraysize;
		buffersize += arraysize;
		leftsize -= arraysize;
		break;
	default:
		break;
	}
	if(leftsize == 0) 
		throw CCProtocol_Invalid("CCProtocol:packs Encode fail: buffer is too short");
	*p=Etx;
	buffersize++;
	p++;
	leftsize--;

	CCProtocol::h2n_32(buffer+0,buffersize); 
}

inline void CCProtocol::UserSession::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:UserSession Decode fail: buffer is too short");
	arraysize = CCProtocol::n2h_16(p);
	if(arraysize < 0 || arraysize+2 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:UserSession Decode fail: buffer is too short");
	name=std::string(p+2,arraysize);
	buffersize-=arraysize+2; p+=arraysize+2;

	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:UserSession Decode fail: buffer is too short");
	type=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

}

inline void CCProtocol::FileAttr::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:FileAttr Decode fail: buffer is too short");
	arraysize = CCProtocol::n2h_16(p);
	if(arraysize < 0 || arraysize+2 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:FileAttr Decode fail: buffer is too short");
	modname=std::string(p+2,arraysize);
	buffersize-=arraysize+2; p+=arraysize+2;

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:FileAttr Decode fail: buffer is too short");
	arraysize = CCProtocol::n2h_16(p);
	if(arraysize < 0 || arraysize+2 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:FileAttr Decode fail: buffer is too short");
	filename=std::string(p+2,arraysize);
	buffersize-=arraysize+2; p+=arraysize+2;

}

inline void CCProtocol::FileContent::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:FileContent Decode fail: buffer is too short");
	arraysize = CCProtocol::n2h_16(p);
	if(arraysize < 0 || arraysize+2 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:FileContent Decode fail: buffer is too short");
	modname=std::string(p+2,arraysize);
	buffersize-=arraysize+2; p+=arraysize+2;

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:FileContent Decode fail: buffer is too short");
	arraysize = CCProtocol::n2h_16(p);
	if(arraysize < 0 || arraysize+2 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:FileContent Decode fail: buffer is too short");
	filename=std::string(p+2,arraysize);
	buffersize-=arraysize+2; p+=arraysize+2;

	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:FileContent Decode fail: buffer is too short");
	arraysize = CCProtocol::n2h_32(p);
	if(arraysize < 0 || arraysize+4 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:FileContent Decode fail: buffer is too short");
	content=std::string(p+4,arraysize);
	buffersize-=arraysize+4; p+=arraysize+4;

}

inline void CCProtocol::FileAttrForBigFile::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:FileAttrForBigFile Decode fail: buffer is too short");
	arraysize = CCProtocol::n2h_16(p);
	if(arraysize < 0 || arraysize+2 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:FileAttrForBigFile Decode fail: buffer is too short");
	modname=std::string(p+2,arraysize);
	buffersize-=arraysize+2; p+=arraysize+2;

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:FileAttrForBigFile Decode fail: buffer is too short");
	arraysize = CCProtocol::n2h_16(p);
	if(arraysize < 0 || arraysize+2 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:FileAttrForBigFile Decode fail: buffer is too short");
	filename=std::string(p+2,arraysize);
	buffersize-=arraysize+2; p+=arraysize+2;

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:FileAttrForBigFile Decode fail: buffer is too short");
	arraysize = CCProtocol::n2h_16(p);
	if(arraysize < 0 || arraysize+2 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:FileAttrForBigFile Decode fail: buffer is too short");
	timestamp=std::string(p+2,arraysize);
	buffersize-=arraysize+2; p+=arraysize+2;

}

inline void CCProtocol::FileContentForBigFile::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:FileContentForBigFile Decode fail: buffer is too short");
	arraysize = CCProtocol::n2h_16(p);
	if(arraysize < 0 || arraysize+2 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:FileContentForBigFile Decode fail: buffer is too short");
	modname=std::string(p+2,arraysize);
	buffersize-=arraysize+2; p+=arraysize+2;

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:FileContentForBigFile Decode fail: buffer is too short");
	arraysize = CCProtocol::n2h_16(p);
	if(arraysize < 0 || arraysize+2 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:FileContentForBigFile Decode fail: buffer is too short");
	filename=std::string(p+2,arraysize);
	buffersize-=arraysize+2; p+=arraysize+2;

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:FileContentForBigFile Decode fail: buffer is too short");
	arraysize = CCProtocol::n2h_16(p);
	if(arraysize < 0 || arraysize+2 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:FileContentForBigFile Decode fail: buffer is too short");
	timestamp=std::string(p+2,arraysize);
	buffersize-=arraysize+2; p+=arraysize+2;

	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:FileContentForBigFile Decode fail: buffer is too short");
	arraysize = CCProtocol::n2h_32(p);
	if(arraysize < 0 || arraysize+4 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:FileContentForBigFile Decode fail: buffer is too short");
	content=std::string(p+4,arraysize);
	buffersize-=arraysize+4; p+=arraysize+4;

}

inline void CCProtocol::PackHead::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:PackHead Decode fail: buffer is too short");
	total=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:PackHead Decode fail: buffer is too short");
	prev=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:PackHead Decode fail: buffer is too short");
	cur=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:PackHead Decode fail: buffer is too short");
	next=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

}

inline void CCProtocol::FileAttr1::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:FileAttr1 Decode fail: buffer is too short");
	arraysize = CCProtocol::n2h_16(p);
	if(arraysize < 0 || arraysize+2 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:FileAttr1 Decode fail: buffer is too short");
	filename=std::string(p+2,arraysize);
	buffersize-=arraysize+2; p+=arraysize+2;

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:FileAttr1 Decode fail: buffer is too short");
	arraysize = CCProtocol::n2h_16(p);
	if(arraysize < 0 || arraysize+2 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:FileAttr1 Decode fail: buffer is too short");
	timestamp=std::string(p+2,arraysize);
	buffersize-=arraysize+2; p+=arraysize+2;

}

inline void CCProtocol::FileChangedAttr::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:FileChangedAttr Decode fail: buffer is too short");
	type=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:FileChangedAttr Decode fail: buffersize is too short");
	arraysize = CCProtocol::n2h_16(p); buffersize-=2; p+=2; 
	files.clear();
	for(unsigned i=0;i<arraysize;i++){
		if(2 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:FileChangedAttr Decode fail: buffer is too short");
		unsigned buffersize2 = CCProtocol::n2h_16(p);
		if(buffersize2+2 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:FileChangedAttr Decode fail: buffer is too short");
		files.push_back(std::string(p+2,buffersize2));
		buffersize-=buffersize2+2; p+=buffersize2+2;
	}

}

inline void CCProtocol::SFileInfo::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:SFileInfo Decode fail: buffer is too short");
	arraysize = CCProtocol::n2h_16(p);
	if(arraysize < 0 || arraysize+2 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:SFileInfo Decode fail: buffer is too short");
	modulename=std::string(p+2,arraysize);
	buffersize-=arraysize+2; p+=arraysize+2;

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:SFileInfo Decode fail: buffer is too short");
	arraysize = CCProtocol::n2h_16(p);
	if(arraysize < 0 || arraysize+2 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:SFileInfo Decode fail: buffer is too short");
	filename=std::string(p+2,arraysize);
	buffersize-=arraysize+2; p+=arraysize+2;

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:SFileInfo Decode fail: buffer is too short");
	arraysize = CCProtocol::n2h_16(p);
	if(arraysize < 0 || arraysize+2 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:SFileInfo Decode fail: buffer is too short");
	md5=std::string(p+2,arraysize);
	buffersize-=arraysize+2; p+=arraysize+2;

}

inline void CCProtocol::SDownloadReq::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:SDownloadReq Decode fail: buffer is too short");
	arraysize = CCProtocol::n2h_16(p);
	if(arraysize < 0 || arraysize+2 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:SDownloadReq Decode fail: buffer is too short");
	modulename=std::string(p+2,arraysize);
	buffersize-=arraysize+2; p+=arraysize+2;

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:SDownloadReq Decode fail: buffer is too short");
	arraysize = CCProtocol::n2h_16(p);
	if(arraysize < 0 || arraysize+2 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:SDownloadReq Decode fail: buffer is too short");
	filename=std::string(p+2,arraysize);
	buffersize-=arraysize+2; p+=arraysize+2;

	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:SDownloadReq Decode fail: buffer is too short");
	startPos=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:SDownloadReq Decode fail: buffer is too short");
	chunkLen=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

}

inline void CCProtocol::GetConfigCS::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:GetConfigCS Decode fail: buffersize is too short");
	arraysize = CCProtocol::n2h_16(p); buffersize-=2; p+=2; 
	files.clear();
	for(unsigned i=0;i<arraysize;i++){
		unsigned buffersize2 = buffersize;
		FileAttr stTmp;
		stTmp.Decode(p,buffersize2);
		files.push_back(stTmp);
		p+=(buffersize-buffersize2); buffersize=buffersize2;
	}
}

inline void CCProtocol::GetConfigSC::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:GetConfigSC Decode fail: buffer is too short");
	result=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:GetConfigSC Decode fail: buffersize is too short");
	arraysize = CCProtocol::n2h_16(p); buffersize-=2; p+=2; 
	configuration.clear();
	for(unsigned i=0;i<arraysize;i++){
		unsigned buffersize2 = buffersize;
		FileContent stTmp;
		stTmp.Decode(p,buffersize2);
		configuration.push_back(stTmp);
		p+=(buffersize-buffersize2); buffersize=buffersize2;
	}
}

inline void CCProtocol::AddModCS::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:AddModCS Decode fail: buffer is too short");
	arraysize = (unsigned char)(*p);
	if(arraysize+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:AddModCS Decode fail: buffer is too short");
	modname=std::string(p+1,arraysize);
	buffersize-=arraysize+1; p+=arraysize+1;

}

inline void CCProtocol::AddModSC::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:AddModSC Decode fail: buffer is too short");
	result=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

}

inline void CCProtocol::AddFileCS::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:AddFileCS Decode fail: buffer is too short");
	arraysize = (unsigned char)(*p);
	if(arraysize+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:AddFileCS Decode fail: buffer is too short");
	modname=std::string(p+1,arraysize);
	buffersize-=arraysize+1; p+=arraysize+1;

	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:AddFileCS Decode fail: buffer is too short");
	arraysize = (unsigned char)(*p);
	if(arraysize+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:AddFileCS Decode fail: buffer is too short");
	filename=std::string(p+1,arraysize);
	buffersize-=arraysize+1; p+=arraysize+1;

	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:AddFileCS Decode fail: buffer is too short");
	arraysize = CCProtocol::n2h_32(p);
	if(arraysize < 0 || arraysize+4 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:AddFileCS Decode fail: buffer is too short");
	configuration=std::string(p+4,arraysize);
	buffersize-=arraysize+4; p+=arraysize+4;

}

inline void CCProtocol::AddFileSC::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:AddFileSC Decode fail: buffer is too short");
	result=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

}

inline void CCProtocol::ModListCS::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
}

inline void CCProtocol::ModListSC::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:ModListSC Decode fail: buffer is too short");
	result=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:ModListSC Decode fail: buffersize is too short");
	arraysize = CCProtocol::n2h_16(p); buffersize-=2; p+=2; 
	modarr.clear();
	for(unsigned i=0;i<arraysize;i++){
		if(1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:ModListSC Decode fail: buffer is too short");
		unsigned buffersize2 = (unsigned char)(*p);
		if(buffersize2+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:ModListSC Decode fail: buffer is too short");
		modarr.push_back(std::string(p+1,buffersize2));
		buffersize-=buffersize2+1; p+=buffersize2+1;
	}

}

inline void CCProtocol::FileListCS::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:FileListCS Decode fail: buffer is too short");
	arraysize = (unsigned char)(*p);
	if(arraysize+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:FileListCS Decode fail: buffer is too short");
	modname=std::string(p+1,arraysize);
	buffersize-=arraysize+1; p+=arraysize+1;

}

inline void CCProtocol::FileListSC::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:FileListSC Decode fail: buffer is too short");
	result=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:FileListSC Decode fail: buffersize is too short");
	arraysize = CCProtocol::n2h_16(p); buffersize-=2; p+=2; 
	files.clear();
	for(unsigned i=0;i<arraysize;i++){
		if(1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:FileListSC Decode fail: buffer is too short");
		unsigned buffersize2 = (unsigned char)(*p);
		if(buffersize2+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:FileListSC Decode fail: buffer is too short");
		files.push_back(std::string(p+1,buffersize2));
		buffersize-=buffersize2+1; p+=buffersize2+1;
	}

}

inline void CCProtocol::FileConfCS::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:FileConfCS Decode fail: buffer is too short");
	arraysize = (unsigned char)(*p);
	if(arraysize+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:FileConfCS Decode fail: buffer is too short");
	modname=std::string(p+1,arraysize);
	buffersize-=arraysize+1; p+=arraysize+1;

	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:FileConfCS Decode fail: buffer is too short");
	arraysize = (unsigned char)(*p);
	if(arraysize+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:FileConfCS Decode fail: buffer is too short");
	filename=std::string(p+1,arraysize);
	buffersize-=arraysize+1; p+=arraysize+1;

}

inline void CCProtocol::FileConfSC::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:FileConfSC Decode fail: buffer is too short");
	result=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:FileConfSC Decode fail: buffer is too short");
	arraysize = CCProtocol::n2h_32(p);
	if(arraysize < 0 || arraysize+4 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:FileConfSC Decode fail: buffer is too short");
	configuration=std::string(p+4,arraysize);
	buffersize-=arraysize+4; p+=arraysize+4;

}

inline void CCProtocol::UpdateFileConfCS::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	arraysize = buffersize;
	userInfo.Decode(p,arraysize);
	p+=(buffersize-arraysize) ;buffersize=arraysize;
	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:UpdateFileConfCS Decode fail: buffer is too short");
	arraysize = (unsigned char)(*p);
	if(arraysize+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:UpdateFileConfCS Decode fail: buffer is too short");
	modname=std::string(p+1,arraysize);
	buffersize-=arraysize+1; p+=arraysize+1;

	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:UpdateFileConfCS Decode fail: buffer is too short");
	arraysize = (unsigned char)(*p);
	if(arraysize+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:UpdateFileConfCS Decode fail: buffer is too short");
	filename=std::string(p+1,arraysize);
	buffersize-=arraysize+1; p+=arraysize+1;

	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:UpdateFileConfCS Decode fail: buffer is too short");
	arraysize = CCProtocol::n2h_32(p);
	if(arraysize < 0 || arraysize+4 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:UpdateFileConfCS Decode fail: buffer is too short");
	configuration=std::string(p+4,arraysize);
	buffersize-=arraysize+4; p+=arraysize+4;

}

inline void CCProtocol::UpdateFileConfSC::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:UpdateFileConfSC Decode fail: buffer is too short");
	result=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

}

inline void CCProtocol::DeleteFileCS::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:DeleteFileCS Decode fail: buffer is too short");
	arraysize = (unsigned char)(*p);
	if(arraysize+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:DeleteFileCS Decode fail: buffer is too short");
	modname=std::string(p+1,arraysize);
	buffersize-=arraysize+1; p+=arraysize+1;

	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:DeleteFileCS Decode fail: buffer is too short");
	arraysize = (unsigned char)(*p);
	if(arraysize+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:DeleteFileCS Decode fail: buffer is too short");
	filename=std::string(p+1,arraysize);
	buffersize-=arraysize+1; p+=arraysize+1;

}

inline void CCProtocol::DeleteFileSC::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:DeleteFileSC Decode fail: buffer is too short");
	result=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

}

inline void CCProtocol::DeleteModCS::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:DeleteModCS Decode fail: buffer is too short");
	arraysize = (unsigned char)(*p);
	if(arraysize+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:DeleteModCS Decode fail: buffer is too short");
	modname=std::string(p+1,arraysize);
	buffersize-=arraysize+1; p+=arraysize+1;

}

inline void CCProtocol::DeleteModSC::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:DeleteModSC Decode fail: buffer is too short");
	result=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

}

inline void CCProtocol::EditConfigCS::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	arraysize = buffersize;
	userInfo.Decode(p,arraysize);
	p+=(buffersize-arraysize) ;buffersize=arraysize;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:EditConfigCS Decode fail: buffer is too short");
	type=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:EditConfigCS Decode fail: buffer is too short");
	arraysize = (unsigned char)(*p);
	if(arraysize+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:EditConfigCS Decode fail: buffer is too short");
	modname=std::string(p+1,arraysize);
	buffersize-=arraysize+1; p+=arraysize+1;

	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:EditConfigCS Decode fail: buffer is too short");
	arraysize = (unsigned char)(*p);
	if(arraysize+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:EditConfigCS Decode fail: buffer is too short");
	filename=std::string(p+1,arraysize);
	buffersize-=arraysize+1; p+=arraysize+1;

}

inline void CCProtocol::EditConfigSC::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:EditConfigSC Decode fail: buffer is too short");
	result=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

}

inline void CCProtocol::MakeVersionCS::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	arraysize = buffersize;
	userInfo.Decode(p,arraysize);
	p+=(buffersize-arraysize) ;buffersize=arraysize;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:MakeVersionCS Decode fail: buffer is too short");
	type=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:MakeVersionCS Decode fail: buffer is too short");
	arraysize = (unsigned char)(*p);
	if(arraysize+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:MakeVersionCS Decode fail: buffer is too short");
	modname=std::string(p+1,arraysize);
	buffersize-=arraysize+1; p+=arraysize+1;

	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:MakeVersionCS Decode fail: buffer is too short");
	arraysize = (unsigned char)(*p);
	if(arraysize+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:MakeVersionCS Decode fail: buffer is too short");
	filename=std::string(p+1,arraysize);
	buffersize-=arraysize+1; p+=arraysize+1;

	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:MakeVersionCS Decode fail: buffer is too short");
	arraysize = (unsigned char)(*p);
	if(arraysize+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:MakeVersionCS Decode fail: buffer is too short");
	version=std::string(p+1,arraysize);
	buffersize-=arraysize+1; p+=arraysize+1;

}

inline void CCProtocol::MakeVersionSC::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:MakeVersionSC Decode fail: buffer is too short");
	result=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

}

inline void CCProtocol::RollBackFileCS::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	arraysize = buffersize;
	userInfo.Decode(p,arraysize);
	p+=(buffersize-arraysize) ;buffersize=arraysize;
	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:RollBackFileCS Decode fail: buffer is too short");
	arraysize = (unsigned char)(*p);
	if(arraysize+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:RollBackFileCS Decode fail: buffer is too short");
	modname=std::string(p+1,arraysize);
	buffersize-=arraysize+1; p+=arraysize+1;

	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:RollBackFileCS Decode fail: buffer is too short");
	arraysize = (unsigned char)(*p);
	if(arraysize+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:RollBackFileCS Decode fail: buffer is too short");
	filename=std::string(p+1,arraysize);
	buffersize-=arraysize+1; p+=arraysize+1;

	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:RollBackFileCS Decode fail: buffer is too short");
	arraysize = (unsigned char)(*p);
	if(arraysize+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:RollBackFileCS Decode fail: buffer is too short");
	version=std::string(p+1,arraysize);
	buffersize-=arraysize+1; p+=arraysize+1;

}

inline void CCProtocol::RollBackFileSC::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:RollBackFileSC Decode fail: buffer is too short");
	result=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

}

inline void CCProtocol::RollBackModCS::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	arraysize = buffersize;
	userInfo.Decode(p,arraysize);
	p+=(buffersize-arraysize) ;buffersize=arraysize;
	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:RollBackModCS Decode fail: buffer is too short");
	arraysize = (unsigned char)(*p);
	if(arraysize+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:RollBackModCS Decode fail: buffer is too short");
	modname=std::string(p+1,arraysize);
	buffersize-=arraysize+1; p+=arraysize+1;

	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:RollBackModCS Decode fail: buffer is too short");
	arraysize = (unsigned char)(*p);
	if(arraysize+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:RollBackModCS Decode fail: buffer is too short");
	version=std::string(p+1,arraysize);
	buffersize-=arraysize+1; p+=arraysize+1;

}

inline void CCProtocol::RollBackModSC::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:RollBackModSC Decode fail: buffer is too short");
	result=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

}

inline void CCProtocol::VersionListCS::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:VersionListCS Decode fail: buffer is too short");
	type=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:VersionListCS Decode fail: buffer is too short");
	arraysize = (unsigned char)(*p);
	if(arraysize+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:VersionListCS Decode fail: buffer is too short");
	modname=std::string(p+1,arraysize);
	buffersize-=arraysize+1; p+=arraysize+1;

	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:VersionListCS Decode fail: buffer is too short");
	arraysize = (unsigned char)(*p);
	if(arraysize+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:VersionListCS Decode fail: buffer is too short");
	filename=std::string(p+1,arraysize);
	buffersize-=arraysize+1; p+=arraysize+1;

}

inline void CCProtocol::VersionListSC::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:VersionListSC Decode fail: buffer is too short");
	result=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:VersionListSC Decode fail: buffersize is too short");
	arraysize = CCProtocol::n2h_16(p); buffersize-=2; p+=2; 
	versionlist.clear();
	for(unsigned i=0;i<arraysize;i++){
		if(1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:VersionListSC Decode fail: buffer is too short");
		unsigned buffersize2 = (unsigned char)(*p);
		if(buffersize2+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:VersionListSC Decode fail: buffer is too short");
		versionlist.push_back(std::string(p+1,buffersize2));
		buffersize-=buffersize2+1; p+=buffersize2+1;
	}

}

inline void CCProtocol::GetBigFileConfCS::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	arraysize = buffersize;
	file.Decode(p,arraysize);
	p+=(buffersize-arraysize) ;buffersize=arraysize;
	arraysize = buffersize;
	filePosition.Decode(p,arraysize);
	p+=(buffersize-arraysize) ;buffersize=arraysize;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:GetBigFileConfCS Decode fail: buffer is too short");
	result=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

}

inline void CCProtocol::GetBigFileConfSC::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:GetBigFileConfSC Decode fail: buffer is too short");
	result=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	arraysize = buffersize;
	head.Decode(p,arraysize);
	p+=(buffersize-arraysize) ;buffersize=arraysize;
	arraysize = buffersize;
	configuration.Decode(p,arraysize);
	p+=(buffersize-arraysize) ;buffersize=arraysize;
}

inline void CCProtocol::GetModChangedFilesCS::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:GetModChangedFilesCS Decode fail: buffer is too short");
	subCmd=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:GetModChangedFilesCS Decode fail: buffer is too short");
	arraysize = (unsigned char)(*p);
	if(arraysize+1 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:GetModChangedFilesCS Decode fail: buffer is too short");
	modName=std::string(p+1,arraysize);
	buffersize-=arraysize+1; p+=arraysize+1;

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:GetModChangedFilesCS Decode fail: buffersize is too short");
	arraysize = CCProtocol::n2h_16(p); buffersize-=2; p+=2; 
	localfiles.clear();
	for(unsigned i=0;i<arraysize;i++){
		unsigned buffersize2 = buffersize;
		FileAttr1 stTmp;
		stTmp.Decode(p,buffersize2);
		localfiles.push_back(stTmp);
		p+=(buffersize-buffersize2); buffersize=buffersize2;
	}
	arraysize = buffersize;
	file.Decode(p,arraysize);
	p+=(buffersize-arraysize) ;buffersize=arraysize;
	arraysize = buffersize;
	filePosition.Decode(p,arraysize);
	p+=(buffersize-arraysize) ;buffersize=arraysize;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:GetModChangedFilesCS Decode fail: buffer is too short");
	result=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

}

inline void CCProtocol::GetModChangedFilesSC::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:GetModChangedFilesSC Decode fail: buffer is too short");
	result=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:GetModChangedFilesSC Decode fail: buffer is too short");
	subCmd=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:GetModChangedFilesSC Decode fail: buffersize is too short");
	arraysize = CCProtocol::n2h_16(p); buffersize-=2; p+=2; 
	files.clear();
	for(unsigned i=0;i<arraysize;i++){
		unsigned buffersize2 = buffersize;
		FileChangedAttr stTmp;
		stTmp.Decode(p,buffersize2);
		files.push_back(stTmp);
		p+=(buffersize-buffersize2); buffersize=buffersize2;
	}
	arraysize = buffersize;
	head.Decode(p,arraysize);
	p+=(buffersize-arraysize) ;buffersize=arraysize;
	arraysize = buffersize;
	configuration.Decode(p,arraysize);
	p+=(buffersize-arraysize) ;buffersize=arraysize;
}

inline void CCProtocol::ResponseSC::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:ResponseSC Decode fail: buffer is too short");
	requestCmd=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:ResponseSC Decode fail: buffer is too short");
	resultCode=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:ResponseSC Decode fail: buffer is too short");
	arraysize = CCProtocol::n2h_16(p);
	if(arraysize < 0 || arraysize+2 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:ResponseSC Decode fail: buffer is too short");
	resultDesc=std::string(p+2,arraysize);
	buffersize-=arraysize+2; p+=arraysize+2;

}

inline void CCProtocol::ResponseCS::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:ResponseCS Decode fail: buffer is too short");
	requestCmd=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:ResponseCS Decode fail: buffer is too short");
	resultCode=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:ResponseCS Decode fail: buffer is too short");
	arraysize = CCProtocol::n2h_16(p);
	if(arraysize < 0 || arraysize+2 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:ResponseCS Decode fail: buffer is too short");
	resultDesc=std::string(p+2,arraysize);
	buffersize-=arraysize+2; p+=arraysize+2;

}

inline void CCProtocol::CmdCheckFileChangedCS::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:CmdCheckFileChangedCS Decode fail: buffersize is too short");
	arraysize = CCProtocol::n2h_16(p); buffersize-=2; p+=2; 
	fileList.clear();
	for(unsigned i=0;i<arraysize;i++){
		unsigned buffersize2 = buffersize;
		SFileInfo stTmp;
		stTmp.Decode(p,buffersize2);
		fileList.push_back(stTmp);
		p+=(buffersize-buffersize2); buffersize=buffersize2;
	}
}

inline void CCProtocol::CmdNeedUpdateFilesSC::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:CmdNeedUpdateFilesSC Decode fail: buffersize is too short");
	arraysize = CCProtocol::n2h_16(p); buffersize-=2; p+=2; 
	fileList.clear();
	for(unsigned i=0;i<arraysize;i++){
		unsigned buffersize2 = buffersize;
		SFileInfo stTmp;
		stTmp.Decode(p,buffersize2);
		fileList.push_back(stTmp);
		p+=(buffersize-buffersize2); buffersize=buffersize2;
	}
}

inline void CCProtocol::CmdDownloadReqCS::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	arraysize = buffersize;
	request.Decode(p,arraysize);
	p+=(buffersize-arraysize) ;buffersize=arraysize;
}

inline void CCProtocol::CmdDownloadRspSC::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	arraysize = buffersize;
	origin.Decode(p,arraysize);
	p+=(buffersize-arraysize) ;buffersize=arraysize;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:CmdDownloadRspSC Decode fail: buffer is too short");
	totalLen=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:CmdDownloadRspSC Decode fail: buffer is too short");
	arraysize = CCProtocol::n2h_32(p);
	if(arraysize < 0 || arraysize+4 > buffersize) 
			throw CCProtocol_Invalid("CCProtocol:CmdDownloadRspSC Decode fail: buffer is too short");
	content=std::string(p+4,arraysize);
	buffersize-=arraysize+4; p+=arraysize+4;

}

inline void CCProtocol::packc::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:packc Decode fail: buffer is too short");
	Len=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:packc Decode fail: buffer is too short");
	Stx=*p; buffersize--; p++; 

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:packc Decode fail: buffer is too short");
	Ver=CCProtocol::n2h_16(p); buffersize-=2; p+=2; 

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:packc Decode fail: buffer is too short");
	Cmd=CCProtocol::n2h_16(p); buffersize-=2; p+=2; 

	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:packc Decode fail: buffer is too short");
	SeqNo=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	switch(Cmd){
	case GetConfig:
		arraysize = buffersize;
		csGetConfig.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case AddMod:
		arraysize = buffersize;
		csAddMod.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case AddFile:
		arraysize = buffersize;
		csAddFile.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case ModList:
		arraysize = buffersize;
		csModList.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case FileList:
		arraysize = buffersize;
		csFileList.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case FileConf:
		arraysize = buffersize;
		csFileConf.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case UpdateFileConf:
		arraysize = buffersize;
		csUpdateFileConf.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case DeleteFile:
		arraysize = buffersize;
		csDeleteFile.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case DeleteMod:
		arraysize = buffersize;
		csDeleteMod.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case EditConfig:
		arraysize = buffersize;
		csEditConfig.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case MakeVersion:
		arraysize = buffersize;
		csMakeVersion.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case RollBackFile:
		arraysize = buffersize;
		csRollBackFile.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case RollBackMod:
		arraysize = buffersize;
		csRollBackMod.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case VersionList:
		arraysize = buffersize;
		csVersionList.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case GetBigFileConf:
		arraysize = buffersize;
		csGetBigFileConf.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case GetModChangedFiles:
		arraysize = buffersize;
		csGetModChangedFiles.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case Response:
		arraysize = buffersize;
		csResponse.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case CmdCheckFileChanged:
		arraysize = buffersize;
		csCmdCheckFileChanged.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case CmdDownloadReq:
		arraysize = buffersize;
		csCmdDownloadReq.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	default:
		break;
	}
	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:packc Decode fail: buffer is too short");
	Etx=*p; buffersize--; p++; 

}

inline void CCProtocol::packs::Decode(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:packs Decode fail: buffer is too short");
	Len=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:packs Decode fail: buffer is too short");
	Stx=*p; buffersize--; p++; 

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:packs Decode fail: buffer is too short");
	Ver=CCProtocol::n2h_16(p); buffersize-=2; p+=2; 

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:packs Decode fail: buffer is too short");
	Cmd=CCProtocol::n2h_16(p); buffersize-=2; p+=2; 

	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:packs Decode fail: buffer is too short");
	SeqNo=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:packs Decode fail: buffer is too short");
	Code=CCProtocol::n2h_16(p); buffersize-=2; p+=2; 

	switch(Cmd){
	case GetConfig:
		arraysize = buffersize;
		scGetConfig.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case AddMod:
		arraysize = buffersize;
		scAddMod.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case AddFile:
		arraysize = buffersize;
		scAddFile.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case ModList:
		arraysize = buffersize;
		scModList.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case FileList:
		arraysize = buffersize;
		scFileList.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case FileConf:
		arraysize = buffersize;
		scFileConf.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case UpdateFileConf:
		arraysize = buffersize;
		scUpdateFileConf.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case DeleteFile:
		arraysize = buffersize;
		scDeleteFile.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case DeleteMod:
		arraysize = buffersize;
		scDeleteMod.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case EditConfig:
		arraysize = buffersize;
		scEditConfig.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case MakeVersion:
		arraysize = buffersize;
		scMakeVersion.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case RollBackFile:
		arraysize = buffersize;
		scRollBackFile.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case RollBackMod:
		arraysize = buffersize;
		scRollBackMod.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case VersionList:
		arraysize = buffersize;
		scVersionList.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case GetBigFileConf:
		arraysize = buffersize;
		scGetBigFileConf.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case GetModChangedFiles:
		arraysize = buffersize;
		scGetModChangedFiles.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case Response:
		arraysize = buffersize;
		scResponse.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case CmdNeedUpdateFiles:
		arraysize = buffersize;
		scCmdNeedUpdateFiles.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	case CmdDownloadRsp:
		arraysize = buffersize;
		scCmdDownloadRsp.Decode(p,arraysize);
		p += buffersize-arraysize;
		buffersize = arraysize;
		break;
	default:
		break;
	}
	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:packs Decode fail: buffer is too short");
	Etx=*p; buffersize--; p++; 

}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::UserSession& st)
{
	ost << "UserSession.name:" << st.name<<"\n";
	ost << "UserSession.type:" << st.type<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::FileAttr& st)
{
	ost << "FileAttr.modname:" << st.modname<<"\n";
	ost << "FileAttr.filename:" << st.filename<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::FileContent& st)
{
	ost << "FileContent.modname:" << st.modname<<"\n";
	ost << "FileContent.filename:" << st.filename<<"\n";
	ost << "FileContent.content:" << st.content<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::FileAttrForBigFile& st)
{
	ost << "FileAttrForBigFile.modname:" << st.modname<<"\n";
	ost << "FileAttrForBigFile.filename:" << st.filename<<"\n";
	ost << "FileAttrForBigFile.timestamp:" << st.timestamp<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::FileContentForBigFile& st)
{
	ost << "FileContentForBigFile.modname:" << st.modname<<"\n";
	ost << "FileContentForBigFile.filename:" << st.filename<<"\n";
	ost << "FileContentForBigFile.timestamp:" << st.timestamp<<"\n";
	ost << "FileContentForBigFile.content:" << st.content<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::PackHead& st)
{
	ost << "PackHead.total:" << st.total<<"\n";
	ost << "PackHead.prev:" << st.prev<<"\n";
	ost << "PackHead.cur:" << st.cur<<"\n";
	ost << "PackHead.next:" << st.next<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::FileAttr1& st)
{
	ost << "FileAttr1.filename:" << st.filename<<"\n";
	ost << "FileAttr1.timestamp:" << st.timestamp<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::FileChangedAttr& st)
{
	ost << "FileChangedAttr.type:" << st.type<<"\n";
	ost << "FileChangedAttr.files.size:" << st.files.size()<<"\n";
	for(unsigned i=0;i<st.files.size();i++){
		ost << st.files[i] << "\n";
	}
	ost << "\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::SFileInfo& st)
{
	ost << "SFileInfo.modulename:" << st.modulename<<"\n";
	ost << "SFileInfo.filename:" << st.filename<<"\n";
	ost << "SFileInfo.md5:" << st.md5<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::SDownloadReq& st)
{
	ost << "SDownloadReq.modulename:" << st.modulename<<"\n";
	ost << "SDownloadReq.filename:" << st.filename<<"\n";
	ost << "SDownloadReq.startPos:" << st.startPos<<"\n";
	ost << "SDownloadReq.chunkLen:" << st.chunkLen<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::GetConfigCS& st)
{
	ost << "GetConfigCS.files.size:" << st.files.size()<<"\n";
	for(unsigned i=0;i<st.files.size();i++){
		ost << st.files[i] << " ";
	}
	ost << "\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::GetConfigSC& st)
{
	ost << "GetConfigSC.result:" << st.result<<"\n";
	ost << "GetConfigSC.configuration.size:" << st.configuration.size()<<"\n";
	for(unsigned i=0;i<st.configuration.size();i++){
		ost << st.configuration[i] << " ";
	}
	ost << "\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::AddModCS& st)
{
	ost << "AddModCS.modname:" << st.modname<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::AddModSC& st)
{
	ost << "AddModSC.result:" << st.result<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::AddFileCS& st)
{
	ost << "AddFileCS.modname:" << st.modname<<"\n";
	ost << "AddFileCS.filename:" << st.filename<<"\n";
	ost << "AddFileCS.configuration:" << st.configuration<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::AddFileSC& st)
{
	ost << "AddFileSC.result:" << st.result<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::ModListCS& st)
{

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::ModListSC& st)
{
	ost << "ModListSC.result:" << st.result<<"\n";
	ost << "ModListSC.modarr.size:" << st.modarr.size()<<"\n";
	for(unsigned i=0;i<st.modarr.size();i++){
		ost << st.modarr[i] << "\n";
	}
	ost << "\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::FileListCS& st)
{
	ost << "FileListCS.modname:" << st.modname<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::FileListSC& st)
{
	ost << "FileListSC.result:" << st.result<<"\n";
	ost << "FileListSC.files.size:" << st.files.size()<<"\n";
	for(unsigned i=0;i<st.files.size();i++){
		ost << st.files[i] << "\n";
	}
	ost << "\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::FileConfCS& st)
{
	ost << "FileConfCS.modname:" << st.modname<<"\n";
	ost << "FileConfCS.filename:" << st.filename<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::FileConfSC& st)
{
	ost << "FileConfSC.result:" << st.result<<"\n";
	ost << "FileConfSC.configuration:" << st.configuration<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::UpdateFileConfCS& st)
{
	ost << "UpdateFileConfCS.userInfo:" << st.userInfo<<"\n";
	ost << "UpdateFileConfCS.modname:" << st.modname<<"\n";
	ost << "UpdateFileConfCS.filename:" << st.filename<<"\n";
	ost << "UpdateFileConfCS.configuration:" << st.configuration<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::UpdateFileConfSC& st)
{
	ost << "UpdateFileConfSC.result:" << st.result<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::DeleteFileCS& st)
{
	ost << "DeleteFileCS.modname:" << st.modname<<"\n";
	ost << "DeleteFileCS.filename:" << st.filename<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::DeleteFileSC& st)
{
	ost << "DeleteFileSC.result:" << st.result<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::DeleteModCS& st)
{
	ost << "DeleteModCS.modname:" << st.modname<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::DeleteModSC& st)
{
	ost << "DeleteModSC.result:" << st.result<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::EditConfigCS& st)
{
	ost << "EditConfigCS.userInfo:" << st.userInfo<<"\n";
	ost << "EditConfigCS.type:" << st.type<<"\n";
	ost << "EditConfigCS.modname:" << st.modname<<"\n";
	ost << "EditConfigCS.filename:" << st.filename<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::EditConfigSC& st)
{
	ost << "EditConfigSC.result:" << st.result<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::MakeVersionCS& st)
{
	ost << "MakeVersionCS.userInfo:" << st.userInfo<<"\n";
	ost << "MakeVersionCS.type:" << st.type<<"\n";
	ost << "MakeVersionCS.modname:" << st.modname<<"\n";
	ost << "MakeVersionCS.filename:" << st.filename<<"\n";
	ost << "MakeVersionCS.version:" << st.version<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::MakeVersionSC& st)
{
	ost << "MakeVersionSC.result:" << st.result<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::RollBackFileCS& st)
{
	ost << "RollBackFileCS.userInfo:" << st.userInfo<<"\n";
	ost << "RollBackFileCS.modname:" << st.modname<<"\n";
	ost << "RollBackFileCS.filename:" << st.filename<<"\n";
	ost << "RollBackFileCS.version:" << st.version<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::RollBackFileSC& st)
{
	ost << "RollBackFileSC.result:" << st.result<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::RollBackModCS& st)
{
	ost << "RollBackModCS.userInfo:" << st.userInfo<<"\n";
	ost << "RollBackModCS.modname:" << st.modname<<"\n";
	ost << "RollBackModCS.version:" << st.version<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::RollBackModSC& st)
{
	ost << "RollBackModSC.result:" << st.result<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::VersionListCS& st)
{
	ost << "VersionListCS.type:" << st.type<<"\n";
	ost << "VersionListCS.modname:" << st.modname<<"\n";
	ost << "VersionListCS.filename:" << st.filename<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::VersionListSC& st)
{
	ost << "VersionListSC.result:" << st.result<<"\n";
	ost << "VersionListSC.versionlist.size:" << st.versionlist.size()<<"\n";
	for(unsigned i=0;i<st.versionlist.size();i++){
		ost << st.versionlist[i] << "\n";
	}
	ost << "\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::GetBigFileConfCS& st)
{
	ost << "GetBigFileConfCS.file:" << st.file<<"\n";
	ost << "GetBigFileConfCS.filePosition:" << st.filePosition<<"\n";
	ost << "GetBigFileConfCS.result:" << st.result<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::GetBigFileConfSC& st)
{
	ost << "GetBigFileConfSC.result:" << st.result<<"\n";
	ost << "GetBigFileConfSC.head:" << st.head<<"\n";
	ost << "GetBigFileConfSC.configuration:" << st.configuration<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::GetModChangedFilesCS& st)
{
	ost << "GetModChangedFilesCS.subCmd:" << st.subCmd<<"\n";
	ost << "GetModChangedFilesCS.modName:" << st.modName<<"\n";
	ost << "GetModChangedFilesCS.localfiles.size:" << st.localfiles.size()<<"\n";
	for(unsigned i=0;i<st.localfiles.size();i++){
		ost << st.localfiles[i] << " ";
	}
	ost << "\n";
	ost << "GetModChangedFilesCS.file:" << st.file<<"\n";
	ost << "GetModChangedFilesCS.filePosition:" << st.filePosition<<"\n";
	ost << "GetModChangedFilesCS.result:" << st.result<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::GetModChangedFilesSC& st)
{
	ost << "GetModChangedFilesSC.result:" << st.result<<"\n";
	ost << "GetModChangedFilesSC.subCmd:" << st.subCmd<<"\n";
	ost << "GetModChangedFilesSC.files.size:" << st.files.size()<<"\n";
	for(unsigned i=0;i<st.files.size();i++){
		ost << st.files[i] << " ";
	}
	ost << "\n";
	ost << "GetModChangedFilesSC.head:" << st.head<<"\n";
	ost << "GetModChangedFilesSC.configuration:" << st.configuration<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::ResponseSC& st)
{
	ost << "ResponseSC.requestCmd:" << st.requestCmd<<"\n";
	ost << "ResponseSC.resultCode:" << st.resultCode<<"\n";
	ost << "ResponseSC.resultDesc:" << st.resultDesc<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::ResponseCS& st)
{
	ost << "ResponseCS.requestCmd:" << st.requestCmd<<"\n";
	ost << "ResponseCS.resultCode:" << st.resultCode<<"\n";
	ost << "ResponseCS.resultDesc:" << st.resultDesc<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::CmdCheckFileChangedCS& st)
{
	ost << "CmdCheckFileChangedCS.fileList.size:" << st.fileList.size()<<"\n";
	for(unsigned i=0;i<st.fileList.size();i++){
		ost << st.fileList[i] << " ";
	}
	ost << "\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::CmdNeedUpdateFilesSC& st)
{
	ost << "CmdNeedUpdateFilesSC.fileList.size:" << st.fileList.size()<<"\n";
	for(unsigned i=0;i<st.fileList.size();i++){
		ost << st.fileList[i] << " ";
	}
	ost << "\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::CmdDownloadReqCS& st)
{
	ost << "CmdDownloadReqCS.request:" << st.request<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::CmdDownloadRspSC& st)
{
	ost << "CmdDownloadRspSC.origin:" << st.origin<<"\n";
	ost << "CmdDownloadRspSC.totalLen:" << st.totalLen<<"\n";
	ost << "CmdDownloadRspSC.content:" << st.content<<"\n";

	return ost;
}

inline void CCProtocol::packc::DecodeHead(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:packc Decode fail: buffer is too short");
	Len=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:packc Decode fail: buffer is too short");
	Stx=*p; buffersize--; p++; 

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:packc Decode fail: buffer is too short");
	Ver=CCProtocol::n2h_16(p); buffersize-=2; p+=2; 

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:packc Decode fail: buffer is too short");
	Cmd=CCProtocol::n2h_16(p); buffersize-=2; p+=2; 

	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:packc Decode fail: buffer is too short");
	SeqNo=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:packc Decode fail: buffer is too short");
	Etx=*p; buffersize--; p++; 

}

inline void CCProtocol::packs::DecodeHead(const char *buffer,unsigned& buffersize) throw(CCProtocol_Invalid)
{
	const char *p;
	p = buffer;
	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:packs Decode fail: buffer is too short");
	Len=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:packs Decode fail: buffer is too short");
	Stx=*p; buffersize--; p++; 

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:packs Decode fail: buffer is too short");
	Ver=CCProtocol::n2h_16(p); buffersize-=2; p+=2; 

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:packs Decode fail: buffer is too short");
	Cmd=CCProtocol::n2h_16(p); buffersize-=2; p+=2; 

	if(4 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:packs Decode fail: buffer is too short");
	SeqNo=CCProtocol::n2h_32(p); buffersize-=4; p+=4; 

	if(2 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:packs Decode fail: buffer is too short");
	Code=CCProtocol::n2h_16(p); buffersize-=2; p+=2; 

	if(1 > buffersize) 
		throw CCProtocol_Invalid("CCProtocol:packs Decode fail: buffer is too short");
	Etx=*p; buffersize--; p++; 

}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::packc& st)
{
	ost << "packc.Len:" << st.Len<<"\n";
	ost << "packc.Stx:" << st.Stx<<"\n";
	ost << "packc.Ver:" << st.Ver<<"\n";
	ost << "packc.Cmd:" << st.Cmd<<"\n";
	ost << "packc.SeqNo:" << st.SeqNo<<"\n";
	switch(st.Cmd){
	case CCProtocol::GetConfig:
		ost << "packc.csGetConfig:" << st.csGetConfig << "\n";
		break;
	case CCProtocol::AddMod:
		ost << "packc.csAddMod:" << st.csAddMod << "\n";
		break;
	case CCProtocol::AddFile:
		ost << "packc.csAddFile:" << st.csAddFile << "\n";
		break;
	case CCProtocol::ModList:
		ost << "packc.csModList:" << st.csModList << "\n";
		break;
	case CCProtocol::FileList:
		ost << "packc.csFileList:" << st.csFileList << "\n";
		break;
	case CCProtocol::FileConf:
		ost << "packc.csFileConf:" << st.csFileConf << "\n";
		break;
	case CCProtocol::UpdateFileConf:
		ost << "packc.csUpdateFileConf:" << st.csUpdateFileConf << "\n";
		break;
	case CCProtocol::DeleteFile:
		ost << "packc.csDeleteFile:" << st.csDeleteFile << "\n";
		break;
	case CCProtocol::DeleteMod:
		ost << "packc.csDeleteMod:" << st.csDeleteMod << "\n";
		break;
	case CCProtocol::EditConfig:
		ost << "packc.csEditConfig:" << st.csEditConfig << "\n";
		break;
	case CCProtocol::MakeVersion:
		ost << "packc.csMakeVersion:" << st.csMakeVersion << "\n";
		break;
	case CCProtocol::RollBackFile:
		ost << "packc.csRollBackFile:" << st.csRollBackFile << "\n";
		break;
	case CCProtocol::RollBackMod:
		ost << "packc.csRollBackMod:" << st.csRollBackMod << "\n";
		break;
	case CCProtocol::VersionList:
		ost << "packc.csVersionList:" << st.csVersionList << "\n";
		break;
	case CCProtocol::GetBigFileConf:
		ost << "packc.csGetBigFileConf:" << st.csGetBigFileConf << "\n";
		break;
	case CCProtocol::GetModChangedFiles:
		ost << "packc.csGetModChangedFiles:" << st.csGetModChangedFiles << "\n";
		break;
	case CCProtocol::Response:
		ost << "packc.csResponse:" << st.csResponse << "\n";
		break;
	case CCProtocol::CmdCheckFileChanged:
		ost << "packc.csCmdCheckFileChanged:" << st.csCmdCheckFileChanged << "\n";
		break;
	case CCProtocol::CmdDownloadReq:
		ost << "packc.csCmdDownloadReq:" << st.csCmdDownloadReq << "\n";
		break;
	default:
		break;
	}
	ost << "packc.Etx:" << st.Etx<<"\n";

	return ost;
}

inline std::ostream& operator<<(std::ostream& ost, const CCProtocol::packs& st)
{
	ost << "packs.Len:" << st.Len<<"\n";
	ost << "packs.Stx:" << st.Stx<<"\n";
	ost << "packs.Ver:" << st.Ver<<"\n";
	ost << "packs.Cmd:" << st.Cmd<<"\n";
	ost << "packs.SeqNo:" << st.SeqNo<<"\n";
	ost << "packs.Code:" << st.Code<<"\n";
	switch(st.Cmd){
	case CCProtocol::GetConfig:
		ost << "packs.scGetConfig:" << st.scGetConfig << "\n";
		break;
	case CCProtocol::AddMod:
		ost << "packs.scAddMod:" << st.scAddMod << "\n";
		break;
	case CCProtocol::AddFile:
		ost << "packs.scAddFile:" << st.scAddFile << "\n";
		break;
	case CCProtocol::ModList:
		ost << "packs.scModList:" << st.scModList << "\n";
		break;
	case CCProtocol::FileList:
		ost << "packs.scFileList:" << st.scFileList << "\n";
		break;
	case CCProtocol::FileConf:
		ost << "packs.scFileConf:" << st.scFileConf << "\n";
		break;
	case CCProtocol::UpdateFileConf:
		ost << "packs.scUpdateFileConf:" << st.scUpdateFileConf << "\n";
		break;
	case CCProtocol::DeleteFile:
		ost << "packs.scDeleteFile:" << st.scDeleteFile << "\n";
		break;
	case CCProtocol::DeleteMod:
		ost << "packs.scDeleteMod:" << st.scDeleteMod << "\n";
		break;
	case CCProtocol::EditConfig:
		ost << "packs.scEditConfig:" << st.scEditConfig << "\n";
		break;
	case CCProtocol::MakeVersion:
		ost << "packs.scMakeVersion:" << st.scMakeVersion << "\n";
		break;
	case CCProtocol::RollBackFile:
		ost << "packs.scRollBackFile:" << st.scRollBackFile << "\n";
		break;
	case CCProtocol::RollBackMod:
		ost << "packs.scRollBackMod:" << st.scRollBackMod << "\n";
		break;
	case CCProtocol::VersionList:
		ost << "packs.scVersionList:" << st.scVersionList << "\n";
		break;
	case CCProtocol::GetBigFileConf:
		ost << "packs.scGetBigFileConf:" << st.scGetBigFileConf << "\n";
		break;
	case CCProtocol::GetModChangedFiles:
		ost << "packs.scGetModChangedFiles:" << st.scGetModChangedFiles << "\n";
		break;
	case CCProtocol::Response:
		ost << "packs.scResponse:" << st.scResponse << "\n";
		break;
	case CCProtocol::CmdNeedUpdateFiles:
		ost << "packs.scCmdNeedUpdateFiles:" << st.scCmdNeedUpdateFiles << "\n";
		break;
	case CCProtocol::CmdDownloadRsp:
		ost << "packs.scCmdDownloadRsp:" << st.scCmdDownloadRsp << "\n";
		break;
	default:
		break;
	}
	ost << "packs.Etx:" << st.Etx<<"\n";

	return ost;
}

#endif

