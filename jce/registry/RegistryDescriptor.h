// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 4.6.0 by WSRD Tencent.
// Generated from `RegistryDescriptor.jce'
// **********************************************************************

#ifndef __REGISTRYDESCRIPTOR_H_
#define __REGISTRYDESCRIPTOR_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
using namespace std;
#include "EndpointF.h"


namespace taf
{
    struct AdapterDescriptor : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "taf.AdapterDescriptor";
        }
        static string MD5()
        {
            return "335f6ac61c6bc73d8512a261bc8865e2";
        }
        AdapterDescriptor()
        :adapterName(""),threadNum(""),endpoint(""),maxConnections(0),allowIp(""),servant(""),queuecap(0),queuetimeout(0),grid(0),protocol(""),handlegroup(""),shmkey(0),shmcap(0)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(adapterName, 0);
            _os.write(threadNum, 1);
            _os.write(endpoint, 2);
            _os.write(maxConnections, 3);
            _os.write(allowIp, 4);
            _os.write(servant, 5);
            _os.write(queuecap, 6);
            _os.write(queuetimeout, 7);
            _os.write(grid, 8);
            _os.write(protocol, 9);
            _os.write(handlegroup, 10);
            _os.write(shmkey, 11);
            _os.write(shmcap, 12);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(adapterName, 0, true);
            _is.read(threadNum, 1, true);
            _is.read(endpoint, 2, true);
            _is.read(maxConnections, 3, true);
            _is.read(allowIp, 4, true);
            _is.read(servant, 5, true);
            _is.read(queuecap, 6, true);
            _is.read(queuetimeout, 7, true);
            _is.read(grid, 8, true);
            _is.read(protocol, 9, false);
            _is.read(handlegroup, 10, false);
            _is.read(shmkey, 11, false);
            _is.read(shmcap, 12, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(adapterName,"adapterName");
            _ds.display(threadNum,"threadNum");
            _ds.display(endpoint,"endpoint");
            _ds.display(maxConnections,"maxConnections");
            _ds.display(allowIp,"allowIp");
            _ds.display(servant,"servant");
            _ds.display(queuecap,"queuecap");
            _ds.display(queuetimeout,"queuetimeout");
            _ds.display(grid,"grid");
            _ds.display(protocol,"protocol");
            _ds.display(handlegroup,"handlegroup");
            _ds.display(shmkey,"shmkey");
            _ds.display(shmcap,"shmcap");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(adapterName, true);
            _ds.displaySimple(threadNum, true);
            _ds.displaySimple(endpoint, true);
            _ds.displaySimple(maxConnections, true);
            _ds.displaySimple(allowIp, true);
            _ds.displaySimple(servant, true);
            _ds.displaySimple(queuecap, true);
            _ds.displaySimple(queuetimeout, true);
            _ds.displaySimple(grid, true);
            _ds.displaySimple(protocol, true);
            _ds.displaySimple(handlegroup, true);
            _ds.displaySimple(shmkey, true);
            _ds.displaySimple(shmcap, false);
            return _os;
        }
    public:
        std::string adapterName;
        std::string threadNum;
        std::string endpoint;
        taf::Int32 maxConnections;
        std::string allowIp;
        std::string servant;
        taf::Int32 queuecap;
        taf::Int32 queuetimeout;
        taf::Int32 grid;
        std::string protocol;
        std::string handlegroup;
        taf::Int32 shmkey;
        taf::Int32 shmcap;
    };
    inline bool operator==(const AdapterDescriptor&l, const AdapterDescriptor&r)
    {
        return l.adapterName == r.adapterName && l.threadNum == r.threadNum && l.endpoint == r.endpoint && l.maxConnections == r.maxConnections && l.allowIp == r.allowIp && l.servant == r.servant && l.queuecap == r.queuecap && l.queuetimeout == r.queuetimeout && l.grid == r.grid && l.protocol == r.protocol && l.handlegroup == r.handlegroup && l.shmkey == r.shmkey && l.shmcap == r.shmcap;
    }
    inline bool operator!=(const AdapterDescriptor&l, const AdapterDescriptor&r)
    {
        return !(l == r);
    }

    struct ServerDescriptor : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "taf.ServerDescriptor";
        }
        static string MD5()
        {
            return "57b22a1c9e7c2e36f1b9679543349d2d";
        }
        ServerDescriptor()
        :application(""),serverName(""),nodeName(""),basePath(""),exePath(""),settingState(""),presentState(""),profile(""),patchVersion(""),patchTime(""),patchUser(""),serverType(""),startScript(""),stopScript(""),monitorScript(""),configCenterPort(0)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(application, 0);
            _os.write(serverName, 1);
            _os.write(nodeName, 2);
            _os.write(basePath, 3);
            _os.write(exePath, 4);
            _os.write(settingState, 5);
            _os.write(presentState, 6);
            _os.write(profile, 7);
            _os.write(patchVersion, 8);
            _os.write(patchTime, 9);
            _os.write(patchUser, 10);
            _os.write(adapters, 11);
            _os.write(serverType, 12);
            _os.write(startScript, 13);
            _os.write(stopScript, 14);
            _os.write(monitorScript, 15);
            _os.write(configCenterPort, 16);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(application, 0, true);
            _is.read(serverName, 1, true);
            _is.read(nodeName, 2, true);
            _is.read(basePath, 3, true);
            _is.read(exePath, 4, true);
            _is.read(settingState, 5, true);
            _is.read(presentState, 6, true);
            _is.read(profile, 7, true);
            _is.read(patchVersion, 8, true);
            _is.read(patchTime, 9, true);
            _is.read(patchUser, 10, true);
            _is.read(adapters, 11, true);
            _is.read(serverType, 12, false);
            _is.read(startScript, 13, false);
            _is.read(stopScript, 14, false);
            _is.read(monitorScript, 15, false);
            _is.read(configCenterPort, 16, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(application,"application");
            _ds.display(serverName,"serverName");
            _ds.display(nodeName,"nodeName");
            _ds.display(basePath,"basePath");
            _ds.display(exePath,"exePath");
            _ds.display(settingState,"settingState");
            _ds.display(presentState,"presentState");
            _ds.display(profile,"profile");
            _ds.display(patchVersion,"patchVersion");
            _ds.display(patchTime,"patchTime");
            _ds.display(patchUser,"patchUser");
            _ds.display(adapters,"adapters");
            _ds.display(serverType,"serverType");
            _ds.display(startScript,"startScript");
            _ds.display(stopScript,"stopScript");
            _ds.display(monitorScript,"monitorScript");
            _ds.display(configCenterPort,"configCenterPort");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(application, true);
            _ds.displaySimple(serverName, true);
            _ds.displaySimple(nodeName, true);
            _ds.displaySimple(basePath, true);
            _ds.displaySimple(exePath, true);
            _ds.displaySimple(settingState, true);
            _ds.displaySimple(presentState, true);
            _ds.displaySimple(profile, true);
            _ds.displaySimple(patchVersion, true);
            _ds.displaySimple(patchTime, true);
            _ds.displaySimple(patchUser, true);
            _ds.displaySimple(adapters, true);
            _ds.displaySimple(serverType, true);
            _ds.displaySimple(startScript, true);
            _ds.displaySimple(stopScript, true);
            _ds.displaySimple(monitorScript, true);
            _ds.displaySimple(configCenterPort, false);
            return _os;
        }
    public:
        std::string application;
        std::string serverName;
        std::string nodeName;
        std::string basePath;
        std::string exePath;
        std::string settingState;
        std::string presentState;
        std::string profile;
        std::string patchVersion;
        std::string patchTime;
        std::string patchUser;
        map<std::string, taf::AdapterDescriptor> adapters;
        std::string serverType;
        std::string startScript;
        std::string stopScript;
        std::string monitorScript;
        taf::Int32 configCenterPort;
    };
    inline bool operator==(const ServerDescriptor&l, const ServerDescriptor&r)
    {
        return l.application == r.application && l.serverName == r.serverName && l.nodeName == r.nodeName && l.basePath == r.basePath && l.exePath == r.exePath && l.settingState == r.settingState && l.presentState == r.presentState && l.profile == r.profile && l.patchVersion == r.patchVersion && l.patchTime == r.patchTime && l.patchUser == r.patchUser && l.adapters == r.adapters && l.serverType == r.serverType && l.startScript == r.startScript && l.stopScript == r.stopScript && l.monitorScript == r.monitorScript && l.configCenterPort == r.configCenterPort;
    }
    inline bool operator!=(const ServerDescriptor&l, const ServerDescriptor&r)
    {
        return !(l == r);
    }

    struct ObjectName : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "taf.ObjectName";
        }
        static string MD5()
        {
            return "2e45701425f70f0e5c722cbe2c3f508e";
        }
        ObjectName()
        :ObjectId("")
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(ObjectId, 0);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(ObjectId, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(ObjectId,"ObjectId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(ObjectId, false);
            return _os;
        }
    public:
        std::string ObjectId;
    };
    inline bool operator==(const ObjectName&l, const ObjectName&r)
    {
        return l.ObjectId == r.ObjectId;
    }
    inline bool operator!=(const ObjectName&l, const ObjectName&r)
    {
        return !(l == r);
    }

    struct ObjectItem : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "taf.ObjectItem";
        }
        static string MD5()
        {
            return "3dc81c5388ee14766c7fc5d7d2b607b4";
        }
        ObjectItem()
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(vActiveEndpoints, 0);
            _os.write(vInactiveEndpoints, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(vActiveEndpoints, 0, true);
            _is.read(vInactiveEndpoints, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(vActiveEndpoints,"vActiveEndpoints");
            _ds.display(vInactiveEndpoints,"vInactiveEndpoints");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(vActiveEndpoints, true);
            _ds.displaySimple(vInactiveEndpoints, false);
            return _os;
        }
    public:
        vector<taf::EndpointF> vActiveEndpoints;
        vector<taf::EndpointF> vInactiveEndpoints;
    };
    inline bool operator==(const ObjectItem&l, const ObjectItem&r)
    {
        return l.vActiveEndpoints == r.vActiveEndpoints && l.vInactiveEndpoints == r.vInactiveEndpoints;
    }
    inline bool operator!=(const ObjectItem&l, const ObjectItem&r)
    {
        return !(l == r);
    }


}

#define taf_AdapterDescriptor_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.adapterName,b.adapterName);jce_copy_struct(a.threadNum,b.threadNum);jce_copy_struct(a.endpoint,b.endpoint);jce_copy_struct(a.maxConnections,b.maxConnections);jce_copy_struct(a.allowIp,b.allowIp);jce_copy_struct(a.servant,b.servant);jce_copy_struct(a.queuecap,b.queuecap);jce_copy_struct(a.queuetimeout,b.queuetimeout);jce_copy_struct(a.grid,b.grid);jce_copy_struct(a.protocol,b.protocol);jce_copy_struct(a.handlegroup,b.handlegroup);jce_copy_struct(a.shmkey,b.shmkey);jce_copy_struct(a.shmcap,b.shmcap);

#define taf_ServerDescriptor_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.application,b.application);jce_copy_struct(a.serverName,b.serverName);jce_copy_struct(a.nodeName,b.nodeName);jce_copy_struct(a.basePath,b.basePath);jce_copy_struct(a.exePath,b.exePath);jce_copy_struct(a.settingState,b.settingState);jce_copy_struct(a.presentState,b.presentState);jce_copy_struct(a.profile,b.profile);jce_copy_struct(a.patchVersion,b.patchVersion);jce_copy_struct(a.patchTime,b.patchTime);jce_copy_struct(a.patchUser,b.patchUser);jce_copy_struct(a.adapters,b.adapters);jce_copy_struct(a.serverType,b.serverType);jce_copy_struct(a.startScript,b.startScript);jce_copy_struct(a.stopScript,b.stopScript);jce_copy_struct(a.monitorScript,b.monitorScript);jce_copy_struct(a.configCenterPort,b.configCenterPort);

#define taf_ObjectName_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.ObjectId,b.ObjectId);

#define taf_ObjectItem_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.vActiveEndpoints,b.vActiveEndpoints);jce_copy_struct(a.vInactiveEndpoints,b.vInactiveEndpoints);



#endif
