// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 4.6.0 by WSRD Tencent.
// Generated from `StatQuery.jce'
// **********************************************************************

#ifndef __STATQUERY_H_
#define __STATQUERY_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
using namespace std;
#include "StatF.h"
#include "servant/ServantProxy.h"
#include "servant/Servant.h"


namespace taf
{
    struct StatQueryKey : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "taf.StatQueryKey";
        }
        static string MD5()
        {
            return "8d61b639cda77ea57102c6b9cbb5aca2";
        }
        StatQueryKey()
        :name(""),ip(""),page(0)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(name, 0);
            _os.write(ip, 1);
            _os.write(page, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(name, 0, true);
            _is.read(ip, 1, true);
            _is.read(page, 2, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(name,"name");
            _ds.display(ip,"ip");
            _ds.display(page,"page");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(name, true);
            _ds.displaySimple(ip, true);
            _ds.displaySimple(page, false);
            return _os;
        }
    public:
        std::string name;
        std::string ip;
        taf::Int32 page;
    };
    inline bool operator==(const StatQueryKey&l, const StatQueryKey&r)
    {
        return l.name == r.name && l.ip == r.ip && l.page == r.page;
    }
    inline bool operator!=(const StatQueryKey&l, const StatQueryKey&r)
    {
        return !(l == r);
    }
    inline bool operator<(const StatQueryKey&l, const StatQueryKey&r)
    {
        if(l.name != r.name)  return (l.name < r.name);
        if(l.ip != r.ip)  return (l.ip < r.ip);
        if(l.page != r.page)  return (l.page < r.page);
        return false;
    }
    inline bool operator<=(const StatQueryKey&l, const StatQueryKey&r)
    {
        return !(r < l);
    }
    inline bool operator>(const StatQueryKey&l, const StatQueryKey&r)
    {
        return r < l;
    }
    inline bool operator>=(const StatQueryKey&l, const StatQueryKey&r)
    {
        return !(l < r);
    }

    struct StatQueryData : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "taf.StatQueryData";
        }
        static string MD5()
        {
            return "2b22122c39da4504cb2246e0c86a6982";
        }
        StatQueryData()
        :curTime(0)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(curTime, 0);
            _os.write(head, 1);
            _os.write(body, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(curTime, 0, true);
            _is.read(head, 1, true);
            _is.read(body, 2, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(curTime,"curTime");
            _ds.display(head,"head");
            _ds.display(body,"body");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(curTime, true);
            _ds.displaySimple(head, true);
            _ds.displaySimple(body, false);
            return _os;
        }
    public:
        taf::Int32 curTime;
        taf::StatMicMsgHead head;
        taf::StatMicMsgBody body;
    };
    inline bool operator==(const StatQueryData&l, const StatQueryData&r)
    {
        return l.curTime == r.curTime && l.head == r.head && l.body == r.body;
    }
    inline bool operator!=(const StatQueryData&l, const StatQueryData&r)
    {
        return !(l == r);
    }

    struct StatQueryValue : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "taf.StatQueryValue";
        }
        static string MD5()
        {
            return "2651062b93a1f68f02de1bc37fa1fa2f";
        }
        StatQueryValue()
        :nextpage(0)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(nextpage, 0);
            _os.write(dataList, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(nextpage, 0, true);
            _is.read(dataList, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(nextpage,"nextpage");
            _ds.display(dataList,"dataList");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(nextpage, true);
            _ds.displaySimple(dataList, false);
            return _os;
        }
    public:
        taf::Int32 nextpage;
        vector<taf::StatQueryData> dataList;
    };
    inline bool operator==(const StatQueryValue&l, const StatQueryValue&r)
    {
        return l.nextpage == r.nextpage && l.dataList == r.dataList;
    }
    inline bool operator!=(const StatQueryValue&l, const StatQueryValue&r)
    {
        return !(l == r);
    }

    struct Db : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "taf.Db";
        }
        static string MD5()
        {
            return "8aef3711ca93f682d5e01ca071c1d888";
        }
        Db()
        :sModule(""),sIp(""),sDbName(""),sTbName(""),sUser(""),sPass(""),sPort("")
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(sModule, 0);
            _os.write(sIp, 1);
            _os.write(sDbName, 2);
            _os.write(sTbName, 3);
            _os.write(sUser, 4);
            _os.write(sPass, 5);
            _os.write(sPort, 6);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(sModule, 0, true);
            _is.read(sIp, 1, true);
            _is.read(sDbName, 2, true);
            _is.read(sTbName, 3, true);
            _is.read(sUser, 4, true);
            _is.read(sPass, 5, true);
            _is.read(sPort, 6, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(sModule,"sModule");
            _ds.display(sIp,"sIp");
            _ds.display(sDbName,"sDbName");
            _ds.display(sTbName,"sTbName");
            _ds.display(sUser,"sUser");
            _ds.display(sPass,"sPass");
            _ds.display(sPort,"sPort");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(sModule, true);
            _ds.displaySimple(sIp, true);
            _ds.displaySimple(sDbName, true);
            _ds.displaySimple(sTbName, true);
            _ds.displaySimple(sUser, true);
            _ds.displaySimple(sPass, true);
            _ds.displaySimple(sPort, false);
            return _os;
        }
    public:
        std::string sModule;
        std::string sIp;
        std::string sDbName;
        std::string sTbName;
        std::string sUser;
        std::string sPass;
        std::string sPort;
    };
    inline bool operator==(const Db&l, const Db&r)
    {
        return l.sModule == r.sModule && l.sIp == r.sIp && l.sDbName == r.sDbName && l.sTbName == r.sTbName && l.sUser == r.sUser && l.sPass == r.sPass && l.sPort == r.sPort;
    }
    inline bool operator!=(const Db&l, const Db&r)
    {
        return !(l == r);
    }


    /* callback of async proxy for client */
    class StatQueryPrxCallback: public taf::ServantProxyCallback
    {
    public:
        virtual ~StatQueryPrxCallback(){}
        virtual void callback_query(taf::Int32 ret,  const taf::StatQueryValue& tValue)
        { throw std::runtime_error("callback_query() overloading incorrect."); }
        virtual void callback_query_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_query_exception() overloading incorrect."); }

        virtual void callback_queryDbInf(taf::Int32 ret,  const taf::Db& tDb)
        { throw std::runtime_error("callback_queryDbInf() overloading incorrect."); }
        virtual void callback_queryDbInf_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_queryDbInf_exception() overloading incorrect."); }

    public:
        int onDispatch(taf::ReqMessagePtr msg);
    };
    typedef taf::TC_AutoPtr<StatQueryPrxCallback> StatQueryPrxCallbackPtr;

    /* proxy for client */
    class StatQueryProxy : public taf::ServantProxy
    {
    public:
        typedef map<string, string> TAF_CONTEXT;
        taf::Int32 query(const taf::StatQueryKey & tKey,taf::Bool bMaster,taf::StatQueryValue &tValue,const map<string, string> &context = TAF_CONTEXT());
        void async_query(StatQueryPrxCallbackPtr callback,const taf::StatQueryKey & tKey,taf::Bool bMaster,const map<string, string> &context = TAF_CONTEXT());

        taf::Int32 queryDbInf(const std::string & sModule,taf::Db &tDb,const map<string, string> &context = TAF_CONTEXT());
        void async_queryDbInf(StatQueryPrxCallbackPtr callback,const std::string & sModule,const map<string, string> &context = TAF_CONTEXT());

        StatQueryProxy* taf_hash(int64_t key);
    };
    typedef taf::TC_AutoPtr<StatQueryProxy> StatQueryPrx;

    /* servant for server */
    class StatQuery : public taf::Servant
    {
    public:
        virtual ~StatQuery(){}
        virtual taf::Int32 query(const taf::StatQueryKey & tKey,taf::Bool bMaster,taf::StatQueryValue &tValue,taf::JceCurrentPtr current) = 0;
        static void async_response_query(taf::JceCurrentPtr current, taf::Int32 _ret, const taf::StatQueryValue &tValue);

        virtual taf::Int32 queryDbInf(const std::string & sModule,taf::Db &tDb,taf::JceCurrentPtr current) = 0;
        static void async_response_queryDbInf(taf::JceCurrentPtr current, taf::Int32 _ret, const taf::Db &tDb);

    public:
        int onDispatch(taf::JceCurrentPtr _current, vector<char> &_sResponseBuffer);
    };


}

#define taf_StatQueryKey_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.name,b.name);jce_copy_struct(a.ip,b.ip);jce_copy_struct(a.page,b.page);

#define taf_StatQueryData_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.curTime,b.curTime);jce_copy_struct(a.head,b.head);jce_copy_struct(a.body,b.body);

#define taf_StatQueryValue_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.nextpage,b.nextpage);jce_copy_struct(a.dataList,b.dataList);

#define taf_Db_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.sModule,b.sModule);jce_copy_struct(a.sIp,b.sIp);jce_copy_struct(a.sDbName,b.sDbName);jce_copy_struct(a.sTbName,b.sTbName);jce_copy_struct(a.sUser,b.sUser);jce_copy_struct(a.sPass,b.sPass);jce_copy_struct(a.sPort,b.sPort);



#endif
