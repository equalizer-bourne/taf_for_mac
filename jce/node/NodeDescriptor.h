// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 4.6.0 by WSRD Tencent.
// Generated from `NodeDescriptor.jce'
// **********************************************************************

#ifndef __NODEDESCRIPTOR_H_
#define __NODEDESCRIPTOR_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
using namespace std;


namespace taf
{
    enum ServerState
    {
        Inactive,
        Activating,
        Active,
        Deactivating,
        Destroying,
        Destroyed,
    };
    inline string etos(const ServerState & e)
    {
        switch(e)
        {
            case Inactive: return "Inactive";
            case Activating: return "Activating";
            case Active: return "Active";
            case Deactivating: return "Deactivating";
            case Destroying: return "Destroying";
            case Destroyed: return "Destroyed";
            default: return "";
        }
        return "";
    }
    inline int stoe(const string & s, ServerState & e)
    {
        if(s == "Inactive")  { e=Inactive; return 0;}
        if(s == "Activating")  { e=Activating; return 0;}
        if(s == "Active")  { e=Active; return 0;}
        if(s == "Deactivating")  { e=Deactivating; return 0;}
        if(s == "Destroying")  { e=Destroying; return 0;}
        if(s == "Destroyed")  { e=Destroyed; return 0;}

        return -1;
    }

    struct LoadInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "taf.LoadInfo";
        }
        static string MD5()
        {
            return "52eced5f8292846b9a6875b8a9e3c192";
        }
        LoadInfo()
        :avg1(0),avg5(0),avg15(0)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(avg1, 0);
            _os.write(avg5, 1);
            _os.write(avg15, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(avg1, 0, true);
            _is.read(avg5, 1, true);
            _is.read(avg15, 2, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(avg1,"avg1");
            _ds.display(avg5,"avg5");
            _ds.display(avg15,"avg15");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(avg1, true);
            _ds.displaySimple(avg5, true);
            _ds.displaySimple(avg15, false);
            return _os;
        }
    public:
        taf::Float avg1;
        taf::Float avg5;
        taf::Float avg15;
    };
    inline bool operator==(const LoadInfo&l, const LoadInfo&r)
    {
        return l.avg1 == r.avg1 && l.avg5 == r.avg5 && l.avg15 == r.avg15;
    }
    inline bool operator!=(const LoadInfo&l, const LoadInfo&r)
    {
        return !(l == r);
    }

    struct PatchInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "taf.PatchInfo";
        }
        static string MD5()
        {
            return "0535c09da10a056cff3232a9de6d9e00";
        }
        PatchInfo()
        :bPatching(false),iPercent(0),iModifyTime(0),sVersion(""),sResult(""),bSucc(false)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(bPatching, 0);
            _os.write(iPercent, 1);
            _os.write(iModifyTime, 2);
            _os.write(sVersion, 3);
            _os.write(sResult, 4);
            _os.write(bSucc, 5);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(bPatching, 0, true);
            _is.read(iPercent, 1, true);
            _is.read(iModifyTime, 2, true);
            _is.read(sVersion, 3, true);
            _is.read(sResult, 4, true);
            _is.read(bSucc, 5, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(bPatching,"bPatching");
            _ds.display(iPercent,"iPercent");
            _ds.display(iModifyTime,"iModifyTime");
            _ds.display(sVersion,"sVersion");
            _ds.display(sResult,"sResult");
            _ds.display(bSucc,"bSucc");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(bPatching, true);
            _ds.displaySimple(iPercent, true);
            _ds.displaySimple(iModifyTime, true);
            _ds.displaySimple(sVersion, true);
            _ds.displaySimple(sResult, true);
            _ds.displaySimple(bSucc, false);
            return _os;
        }
    public:
        taf::Bool bPatching;
        taf::Int32 iPercent;
        taf::Int32 iModifyTime;
        std::string sVersion;
        std::string sResult;
        taf::Bool bSucc;
    };
    inline bool operator==(const PatchInfo&l, const PatchInfo&r)
    {
        return l.bPatching == r.bPatching && l.iPercent == r.iPercent && l.iModifyTime == r.iModifyTime && l.sVersion == r.sVersion && l.sResult == r.sResult && l.bSucc == r.bSucc;
    }
    inline bool operator!=(const PatchInfo&l, const PatchInfo&r)
    {
        return !(l == r);
    }

    struct NodeInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "taf.NodeInfo";
        }
        static string MD5()
        {
            return "216bebf42a2455b71fd0e4fc8b348451";
        }
        NodeInfo()
        :nodeName(""),nodeObj(""),endpointIp(""),endpointPort(0),timeOut(0),dataDir(""),version("")
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(nodeName, 0);
            _os.write(nodeObj, 1);
            _os.write(endpointIp, 2);
            _os.write(endpointPort, 3);
            _os.write(timeOut, 4);
            _os.write(dataDir, 5);
            _os.write(version, 6);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(nodeName, 0, true);
            _is.read(nodeObj, 1, true);
            _is.read(endpointIp, 2, true);
            _is.read(endpointPort, 3, true);
            _is.read(timeOut, 4, true);
            _is.read(dataDir, 5, true);
            _is.read(version, 6, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(nodeName,"nodeName");
            _ds.display(nodeObj,"nodeObj");
            _ds.display(endpointIp,"endpointIp");
            _ds.display(endpointPort,"endpointPort");
            _ds.display(timeOut,"timeOut");
            _ds.display(dataDir,"dataDir");
            _ds.display(version,"version");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(nodeName, true);
            _ds.displaySimple(nodeObj, true);
            _ds.displaySimple(endpointIp, true);
            _ds.displaySimple(endpointPort, true);
            _ds.displaySimple(timeOut, true);
            _ds.displaySimple(dataDir, true);
            _ds.displaySimple(version, false);
            return _os;
        }
    public:
        std::string nodeName;
        std::string nodeObj;
        std::string endpointIp;
        taf::Int32 endpointPort;
        taf::Short timeOut;
        std::string dataDir;
        std::string version;
    };
    inline bool operator==(const NodeInfo&l, const NodeInfo&r)
    {
        return l.nodeName == r.nodeName && l.nodeObj == r.nodeObj && l.endpointIp == r.endpointIp && l.endpointPort == r.endpointPort && l.timeOut == r.timeOut && l.dataDir == r.dataDir && l.version == r.version;
    }
    inline bool operator!=(const NodeInfo&l, const NodeInfo&r)
    {
        return !(l == r);
    }

    struct ServerStateInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "taf.ServerStateInfo";
        }
        static string MD5()
        {
            return "996b060966ea932c8615930efc07d022";
        }
        ServerStateInfo()
        :processId(0),nodeName(""),application(""),serverName("")
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write((taf::Int32)serverState, 0);
            _os.write(processId, 1);
            _os.write(nodeName, 2);
            _os.write(application, 3);
            _os.write(serverName, 4);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read((taf::Int32&)serverState, 0, true);
            _is.read(processId, 1, true);
            _is.read(nodeName, 2, false);
            _is.read(application, 3, false);
            _is.read(serverName, 4, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display((taf::Int32)serverState,"serverState");
            _ds.display(processId,"processId");
            _ds.display(nodeName,"nodeName");
            _ds.display(application,"application");
            _ds.display(serverName,"serverName");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple((taf::Int32)serverState, true);
            _ds.displaySimple(processId, true);
            _ds.displaySimple(nodeName, true);
            _ds.displaySimple(application, true);
            _ds.displaySimple(serverName, false);
            return _os;
        }
    public:
        taf::ServerState serverState;
        taf::Int32 processId;
        std::string nodeName;
        std::string application;
        std::string serverName;
    };
    inline bool operator==(const ServerStateInfo&l, const ServerStateInfo&r)
    {
        return l.serverState == r.serverState && l.processId == r.processId && l.nodeName == r.nodeName && l.application == r.application && l.serverName == r.serverName;
    }
    inline bool operator!=(const ServerStateInfo&l, const ServerStateInfo&r)
    {
        return !(l == r);
    }


}

#define taf_LoadInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.avg1,b.avg1);jce_copy_struct(a.avg5,b.avg5);jce_copy_struct(a.avg15,b.avg15);

#define taf_PatchInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.bPatching,b.bPatching);jce_copy_struct(a.iPercent,b.iPercent);jce_copy_struct(a.iModifyTime,b.iModifyTime);jce_copy_struct(a.sVersion,b.sVersion);jce_copy_struct(a.sResult,b.sResult);jce_copy_struct(a.bSucc,b.bSucc);

#define taf_NodeInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.nodeName,b.nodeName);jce_copy_struct(a.nodeObj,b.nodeObj);jce_copy_struct(a.endpointIp,b.endpointIp);jce_copy_struct(a.endpointPort,b.endpointPort);jce_copy_struct(a.timeOut,b.timeOut);jce_copy_struct(a.dataDir,b.dataDir);jce_copy_struct(a.version,b.version);

#define taf_ServerStateInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.serverState,b.serverState);jce_copy_struct(a.processId,b.processId);jce_copy_struct(a.nodeName,b.nodeName);jce_copy_struct(a.application,b.application);jce_copy_struct(a.serverName,b.serverName);



#endif
